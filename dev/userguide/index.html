<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User guide · Sequences</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Sequences logo"/></a><h1>Sequences</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../about/">About</a></li><li><a class="toctext" href="../">Sequences</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../notebooks/">Notebooks and demos</a></li><li class="current"><a class="toctext" href>User guide</a><ul class="internal"><li><a class="toctext" href="#Naming-conventions-1">Naming conventions</a></li><li><a class="toctext" href="#Number-triangles-1">Number triangles</a></li><li><a class="toctext" href="#Notebook-1">Notebook</a></li><li><a class="toctext" href="#Contribute!-1">Contribute!</a></li></ul></li><li><a class="toctext" href="../developerguide/">Developer guide</a></li><li><a class="toctext" href="../useofoeis/">Use of the OEIS</a></li><li><a class="toctext" href="../license/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>User guide</a></li></ul><a class="edit-page" href="https://github.com/OpenLibMathSeq/Sequences.jl/blob/master/docs/src/userguide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-Guide-1" href="#User-Guide-1">User Guide</a></h1><h2><a class="nav-anchor" id="Naming-conventions-1" href="#Naming-conventions-1">Naming conventions</a></h2><p>The function names follow the registration numbers of the <a href="https://oeis.org &quot;Online Encyclopedia of Integer Sequences&quot;">OEIS</a>. We use the following prefixes to indicate the type of the function.</p><table><tr><th>Prefix</th><th>Function Type</th></tr><tr><td>C</td><td>Coroutine (channel)</td></tr><tr><td>F</td><td>Filter (not exceeding n)</td></tr><tr><td>G</td><td>Generating function</td></tr><tr><td>I</td><td>Iteration (over n terms)</td></tr><tr><td>L</td><td>List (array based)</td></tr><tr><td>M</td><td>Matrix (2-dim square)</td></tr><tr><td>R</td><td>Real function (Float64)</td></tr><tr><td>S</td><td>Staircase (list iteration)</td></tr><tr><td>T</td><td>Triangle (list iteration)</td></tr><tr><td>TA</td><td>Triangle (triangular array)</td></tr><tr><td>TL</td><td>Triangle (flat-list array)</td></tr><tr><td>V</td><td>Value (single term)</td></tr><tr><td>is</td><td>is a member (predicate query)</td></tr></table><p>These conventions can be seen as an application programming interface which we explain by three examples.</p><h3><a class="nav-anchor" id="Example-1:-Fibonacci-numbers-1" href="#Example-1:-Fibonacci-numbers-1">Example 1: Fibonacci numbers</a></h3><p>For the Fibonacci numbers we offer 7 functions:</p><pre><code class="language-none">I000045, F000045, G000045, L000045, V000045, R000045, is000045.</code></pre><p>Four of those are based on the iteration protocol <code>FiboIterate</code> which is kept intern. The implementations are:</p><ul><li>Iterate over the first <span>$n$</span> Fibonacci numbers.</li></ul><pre><code class="language-javascript">I000045(n) = FiboIterate(n)</code></pre><ul><li>Iterate over the Fibonacci numbers which do not exceed <span>$n$</span>.</li></ul><pre><code class="language-javascript">F000045(n) = takewhile(k -&gt; k &lt;= n, FiboIterate(n+1))</code></pre><ul><li>Return the first <span>$n$</span> Fibonacci numbers in an array.</li></ul><pre><code class="language-javascript">L000045(n) = collect(FiboIterate(n))</code></pre><p>Alternatively one can use a generating function if available:</p><pre><code class="language-javascript">L000045(n) = coefficients(G000045, n)</code></pre><ul><li>Return the <span>$n$</span>-th Fibonacci number.</li></ul><pre><code class="language-javascript">function V000045(n)
   F = ZZ[1 1; 1 0]
   Fn = F^n
   Fn[2, 1]
end</code></pre><ul><li>Fibonacci function for real values, returns a Float64.</li></ul><pre><code class="language-javascript">function R000045(x::Float64)
    (Base.MathConstants.golden^x - cos(x Base.MathConstants.pi)
        Base.MathConstants.golden^(-x)) / sqrt(5)
end</code></pre><ul><li>Query if <span>$n$</span> is a Fibonacci number, returns a Bool.</li></ul><pre><code class="language-javascript">function is000045(n)
    d = 0
    for f in FiboIterate(n+2)
        d = n - f
        d &lt;= 0 &amp;&amp; break
    end
    d == 0
end</code></pre><h3><a class="nav-anchor" id="Example-2:-Abundant-numbers-1" href="#Example-2:-Abundant-numbers-1">Example 2: Abundant numbers</a></h3><p>For the abundant numbers (i.e. numbers n where the sum of divisors exceeds 2n) we offer 5 functions:</p><p>is005101, I005101, F005101, L005101, V005101</p><ul><li>Is <span>$n$</span> an abundant number, i.e. is <span>$σ(n) &gt; 2 n$</span> ?</li></ul><pre><code class="language-javascript">is005101(n) = σ(n) &gt; 2 n</code></pre><ul><li>Iterate over the first <span>$n$</span> abundant numbers.</li></ul><pre><code class="language-javascript">I005101(n) = takefirst(isAbundant, n)</code></pre><ul><li>Iterate over the abundant numbers which do not exceed <span>$n$</span>.</li></ul><pre><code class="language-javascript">F005101(n) = filter(isAbundant, 1:n)</code></pre><ul><li>Return the first <span>$n$</span> abundant numbers in an array.</li></ul><pre><code class="language-javascript">L005101(n) = collect(I005101(n))</code></pre><ul><li>Return the value of the <span>$n$</span>-th abundant number.</li></ul><pre><code class="language-javascript">V005101(n) = nth(I005101(n), n)</code></pre><h2><a class="nav-anchor" id="Number-triangles-1" href="#Number-triangles-1">Number triangles</a></h2><h4><a class="nav-anchor" id="Definition-1" href="#Definition-1">Definition</a></h4><p>To construct a number triangle one has to provide a function t(n, k) defined for all integers n and k with n &gt;= 0 and 0 &lt;= k &lt;= n. Note that this corresponds to an infinite lower triangular matrix which is (0, 0)-based. This deviates from the usual indexing of Julia matrices which are (1, 1)-based, but the mother of all number triangles is Pascal&#39;s triangle which is (0, 0)-based and in our application it is more convenient to follow the lead of Blaise than that of Julia.</p><p>The matrix view of a number triangle of dimension dim has dim rows and the n-th row has length n. Note that the rows are enumerated like the terms 0, 1, 2, ...</p><pre><code class="language-javascript">    T(0,0)                          row 0
    T(1,0) T(1,1)                   row 1
    T(2,0) T(2,1) T(2,2)            row 2
    T(3,0) T(3,1) T(3,2) T(3,3)     row 3</code></pre><p>However, our model is not that of a matrix, rather that of an iteration, actually an iteration over lists. In this abstract view a triangle T is a chain of lists. On the first level a triangle iterates over the rows of the triangle and on the secondary level over the terms of the rows, which are given by the user-supplied function t(n, k).</p><pre><code class="language-javascript">    T = (row(0), row(1), ..., row(dim-1))
    Row(T, n) = [t(n, 0), t(n, 1), ..., t(n, n)]</code></pre><h4><a class="nav-anchor" id="Constructing-1" href="#Constructing-1">Constructing</a></h4><p>Sequence A097805 gives the number of ordered partitions of n into k parts. The corresponding triangle can be constructed like this:</p><ul><li>Triangle T097805 based of explicite value.</li></ul><pre><code class="language-javascript">V097805(n, k) = k == 0 ? k^n : binomial(n-1, k-1)
T097805(dim) = Triangle(dim, V097805)</code></pre><p>Many number triangles can be efficiently implemented by recurrence. To support this the type RecTriangle has a buffer which saves the previously computed row. This buffer can be accessed through a function &#39;prevrow&#39;.  </p><ul><li>Triangle T097805 based on recurrence.</li></ul><pre><code class="language-javascript">R097805(n, k, prevrow) = k == 0 ? k^n : prevrow(k-1) + prevrow(k)
T097805(dim) = RecTriangle(dim, R097805)</code></pre><p>This function is much more efficient than the version above. Note that you do not have to provide the function prevrow as long as you use the function R097805 in the definition of a triangle. The name &#39;prevrow&#39; is not fixed but recommended as a convention. A nice alternative for &#39;prevrow&#39; is &#39;Tn<em>1&#39; because Tn</em>1(k) = T(n-1, k) in matrix notation.</p><h4><a class="nav-anchor" id="Triangle-tools-1" href="#Triangle-tools-1">Triangle tools</a></h4><p>The following functions are supplied:</p><ul><li>Return the row n (0 &lt;= n &lt; dim) of a triangle.</li></ul><pre><code class="language-javascript">Row(T::Triangle, n::Int, rev=true) = rev ? reversed(T(n)) : T(n)</code></pre><p>If in the call the third – optional – parameter <code>rev</code> is true the row is returned in reversed order.</p><ul><li>Return the triangle as a list of rows.</li></ul><pre><code class="language-javascript">TriangularArray(T::Triangle) = [row for row in T]</code></pre><ul><li>Return the triangle as a list of integers.</li></ul><pre><code class="language-javascript">TriangleToList(T::Triangle) = [k for row in T for k in row]</code></pre><p>Thus applying TriangleToList to a triangle of dimension dim returns a list of integers of length dim(dim + 1)/2. Conversely, given an integer list of length n(n + 1)/2 the function ListToTriangle returns a triangle as a chain of iterators.</p><pre><code class="language-javascript">ListToTriangle(A::Array{})</code></pre><h2><a class="nav-anchor" id="Notebook-1" href="#Notebook-1">Notebook</a></h2><p>More examples can be found in this <a href="https://github.com/OpenLibMathSeq/Sequences.jl/blob/master/demos/SequencesIntro.ipynb">Jupyter notebook</a>.</p><h2><a class="nav-anchor" id="Contribute!-1" href="#Contribute!-1">Contribute!</a></h2><p>Sequences are fun!  </p><ul><li>Start with cloning the module <a href="https://github.com/OpenLibMathSeq/Sequences.jl/blob/master/src/NarayanaCows.jl">NarayanaCows</a></li></ul><p>as a blueprint. Replace what is to be replaced.</p><ul><li><p>Execute the module &#39;BuildSequences&#39; which will integrate your module into &#39;Sequences&#39;.</p></li><li><p>Send us a pull request.</p></li></ul><p>We want to include only sequences which are of mathematical interest. Please make sure that they are already documented in the Online Encyclopedia of Integer Sequences, otherwise please submit them first to the OEIS.</p><p>We prefer parametrized sequences (family of sequences) over single ones and triangles (family of polynomials) over straight sequences. Implementations of sequence-to-sequence transformations are always welcome.</p><footer><hr/><a class="previous" href="../notebooks/"><span class="direction">Previous</span><span class="title">Notebooks and demos</span></a><a class="next" href="../developerguide/"><span class="direction">Next</span><span class="title">Developer guide</span></a></footer></article></body></html>
