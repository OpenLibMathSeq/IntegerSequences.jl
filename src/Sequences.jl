# This file is part of Sequences.
# Copyright Peter Luschny. License is MIT.
# This file includes parts from Combinatorics.jl in modified form.
# Version of: UTC 2019-04-30 11:23:27
# 9c509a30-6b29-11e9-37db-83b83d401682
# Do not edit this file, it is generated from the modules and will be overwritten!
# Edit the modules in the src directory and build this file with BuildSequences.jl!
__precompile__()
module Sequences
using Nemo, IterTools, HTTP, DocStringExtensions
export 
André,
BellNumber,
BellNumberList,
BellTrans,
BellTriangle,
Bernoulli,
BernoulliInt,
BernoulliIntList,
BernoulliList,
Bil,
BinaryIntegerLength,
Binomial,
ClausenNumber,
ClausenNumberList,
Coefficients,
Combinations,
Count,
DedekindEtaPowers,
DeléhamΔ,
Divides,
Divisors,
F!,
Factors,
FallingFactorial,
GammaHyp,
HilbertHotel,
InvOrthoPoly,
JacobiTheta3Powers,
JacobiTheta4Powers,
KolakoskiList,
List,
MultiFactorial,
NarayanasCows,
Nemofmpz,
NextPrime,
Nth,
OrthoPoly,
PSfactorial,
Partition,
PartitionNumberList,
Pascal,
PolygonalNumber,
PreviousPrime,
PrimeDivisors,
PrimeList,
PrimePi,
PrimePiList,
PrimeSieve,
Primes,
Println,
Product,
PyramidalNumber,
QTriangle,
Queens,
Radical,
RamanujanTau,
RamanujanTauList,
RecTriangle,
Records,
RiordanProduct,
RiordanSquare,
RisingFactorial,
Row,
RowSums,
SelfConvRec,
SeqName,
SeqNum,
SeqPrint,
SeqShow,
Sfactorial,
ShowAsMatrix,
ShowAsΔ,
Swing,
Triangle,
TriangleToList,
TriangularNumber,
UlamList,
ZArray,
ZTriangle,
assertTriangular,
fromΔ,
isAbundant,
isCarmichael,
isComposite,
isCyclic,
isEven,
isNonnegative,
isOdd,
isPerfectPower,
isPositive,
isPowerOfPrimes,
isPrime,
isPrimePower,
isPrimeTo,
isSquare,
isSquareFree,
isStrongCyclic,
isStrongPrimeTo,
isTriangular,
isUlam,
isZumkeller,
mods,
oeis_isinstalled,
oeis_local,
oeis_notinstalled,
oeis_path,
oeis_readbfile,
oeis_remote,
oeis_search,
oeis_trimdata,
oeis_writebfile,
takefirst,
toΔ,
Ω,
σ,
τ,
ω,
ϕ,
↑,
↓,
∏,
⊥,
⍊,
C000002,I000002,L000002,
V000005,
V000010,
G000032,L000032,
L000041,
F000045,G000045,I000045,L000045,R000045,V000045,is000045,
G000073,L000073,
L000085,
G000108,L000108,
L000110,V000110,
C000111,V000111,
L000118,
L000122,
L000132,
L000141,
V000142,
L000143,
L000144,
L000145,
V000165,
V000203,
V000217,
V000255,
G000257,L000257,
V000262,
V000290,
V000292,
V000326,
V000330,
T000369,
V000384,
V000407,
V000566,
V000567,
L000594,
L000698,
L000712,
L000716,
L000720,
L000727,
L000728,
L000729,
L000730,
L000731,
L000735,
L000739,
G000957,L000957,
L000961,
G001003,L001003,
G001006,L001006,
G001045,L001045,
V001106,
V001107,
V001147,
V001221,
V001222,
V001339,
L001464,
V001477,
T001497,
L001710,
V001813,
V001855,
L001934,
F002093,I002093,L002093,V002093,
L002107,
V002110,
V002411,
V002412,
V002413,
V002414,
G002426,L002426,
L002445,V002445,
L002448,
L002476,
L002808,
L002858,
F002997,I002997,L002997,
I003277,L003277,
V003314,
L003319,
L003723,
L004018,
L004402,
L004403,
L004404,
L004405,
L004406,
L004407,
L004408,
L004409,
L004410,
L004411,
L004412,
L004413,
L004414,
L004415,
L004416,
L004417,
L004418,
L004419,
L004420,
L004421,
L004422,
L004423,
L004424,
L004425,
T004747,
G005043,L005043,
F005101,I005101,L005101,V005101,is005101,
L005117,
L005411,
L005412,
L005425,
V005564,
L005758,
L005773,
L005875,
L006012,
L006229,
G006318,L006318,
L006922,
V007060,
T007318,
L007522,
V007559,
V007584,
V007585,
V007696,
A007917,
I008279,L008279,M008279,V008279,
L008451,
L008452,
L008453,
V008544,
V008545,
V008683,
L008784,
L010815,
L010816,
L010817,
L010819,
L010820,
L010821,
L010822,
L010823,
L010824,
L010825,
L010826,
L010827,
L010828,
L010829,
L010830,
L010831,
L010832,
L010833,
L010834,
L010835,
L010836,
L010837,
L010838,
L010839,
L010840,
L010841,
T011117,
L013928,
V014107,
L015128,
L023003,
L023004,
L023005,
L023006,
L023007,
L023008,
L023009,
L023010,
L023011,
L023012,
L023013,
L023014,
L023015,
L023016,
L023017,
L023018,
L023019,
L023020,
L023021,
L025528,
V027641,
V027642,
L031363,
V032031,
V033156,
L033200,
V033815,
L034017,
V034386,
V034444,
F034885,I034885,L034885,V034885,
L035016,
L035251,
T037027,
L038872,
L038873,
T039599,
T039683,
L042965,
V047053,
L047891,
I048993,L048993,M048993,V048993,
T049218,
T049310,
I050384,L050384,
T051141,
T051142,
T053117,
T053120,
T053121,
V054248,
T055883,
L057126,
L057127,
V058373,
T059419,
T060693,
V061142,
V061168,
L062980,
T064189,
L065515,
L065619,V065619,
L065855,
T066325,
V067998,
L068228,
G068875,L068875,
L069637,
V080577,
V080956,
V081125,
L082298,
L082301,
L082302,
L082556,
L082557,
L082558,
L082559,
F083207,I083207,L083207,V083207,is083207,
V083652,
L084916,
T084938,
T088969,
L089270,
T090238,
T090981,
I094587,L094587,M094587,V094587,
T094665,
V095794,
L096727,
V097383,
I097805,L097805,M097805,V097805,
V099022,
T099174,
T104556,
T104562,
L104794,
L105523,
T106566,
L107716,
L108624,
T111062,
L111529,
L111530,
L111531,
L111532,
L111533,
T111593,
T116392,
T119274,
V123753,
V124320,
T132062,
I132393,L132393,M132393,V132393,
T137286,
T137338,
T137452,
T137513,
L141158,
L146559,
A151800,
T159834,
L167872,
T172094,
V178963,
V178964,
V181830,
V181936,
T184962,
F193338,I193338,L193338,V193338,
F193339,I193339,L193339,V193339,
V195441,
T202327,
T203412,
L213384,
L214551,
T216916,
T217537,
L217924,
T225478,
L242660,
L243168,
L243655,
L244291,
L244779,
L244780,
L244819,
L246547,
L246655,
V250283,
V251568,
V254749,
A257993,
T264428,
T265606,
V265609,
I271703,L271703,M271703,V271703,
L276285,
L276286,
L276287,
V281586,
V281588,
V295513,
L319284,
T321620,
T321621,
T321623,
T321624,
T322942
# *** Abundant.jl ****************
"""
Is ``n`` an abundant number, i.e. is ``σ(n) > 2n`` ?
$(SIGNATURES)
"""
isAbundant(n) = σ(n) > 2n
"""
Is ``n`` a term of sequence A005101?
$(SIGNATURES)
"""
is005101(n) = isAbundant(n)
"""
Iterate over the first ``n`` abundant numbers.
$(SIGNATURES)
"""
I005101(n) = takefirst(isAbundant, n)
"""
Iterate over the abundant numbers which do not exceed ``n (1 ≤ i ≤ n)``.
$(SIGNATURES)
"""
F005101(n) = Iterators.filter(isAbundant, 1:n)
"""
Return a list of the  first ``n`` abundant numbers.
$(SIGNATURES)
"""
L005101(n) = collect(I005101(n))
"""
Return the value of the ``n``-th abundant number.
$(SIGNATURES)
"""
V005101(n) = nth(I005101(n), n)
# *** AndreNumbers.jl ****************
"""
Return the generalized André numbers which are the ``m``-alternating permutations of length ``n``, cf. A181937.
$(SIGNATURES)
"""
function André(m::Int, n::Int)
    if haskey(CacheAndré, (m, n))
        return CacheAndré[(m, n)]
    end
    n ≤ 0 && return fmpz(1)
    r = range(0, step=m, stop=n-1)
    S = sum(binom(n, k) * André(m, k) for k in r)
    V = n % m == 0 ? -S : S
    CacheAndré[(m, n)] = V
    return V
end
const CacheAndré = Dict{Tuple{Int, Int}, fmpz}()
"""
Return the generalized André numbers which are the ``m``-alternating permutations of length ``n``.
$(SIGNATURES)
"""
V181937(m::Int, n::Int) = abs(André(m, n))
"""
Return the up-down numbers (2-alternating permutations).
$(SIGNATURES)
"""
V000111(n::Int) = abs(André(2, n))
"""
Return the number of 3-alternating permutations.
$(SIGNATURES)
"""
V178963(n::Int) = abs(André(3, n))
"""
Return the number of 4-alternating permutations.
$(SIGNATURES)
"""
V178964(n::Int) = abs(André(4, n))
"""
Return the number of 5-alternating permutations.
$(SIGNATURES)
"""
V181936(n::Int) = abs(André(5, n))
"""
Return the number of 6-alternating permutations.
$(SIGNATURES)
"""
V250283(n::Int) = abs(André(6, n))
"""
Generate the André numbers (a.k.a. Euler-up-down numbers A000111). Don't confuse with the Euler numbers A122045.
$(SIGNATURES)
"""
C000111() = Channel(csize=2) do c
    D = Dict{Int,fmpz}(0 => 1, -1 => 0)
    i = k = 0
    s = 1
    while true
        A = 0; D[k + s] = 0; s = -s
        for j in 0:i
            A += D[k]; D[k] = A; k += s
        end
        put!(c, A)
        i += 1
    end
end
# *** BellNumbers.jl ****************
"""
Return a list of the first m Bell numbers (a.k.a. exponential numbers).
$(SIGNATURES)
"""
function BellNumberList(m::Int)
    m == 0 && return fmpz[]
    R = ZArray(m)
    R[1] = 1; m == 1 && return R
    R[2] = 1; m == 2 && return R
    A = ZArray(m)
    A[1] = fmpz(1)
    for n in 2:m - 1
        A[n] = A[1]
        for k in n:-1:2
            A[k - 1] += A[k]
        end
        R[n + 1] = A[1]
    end
    R
end
"""
Return the n-th Bell number. Bell numbers count the ways to partition a set of ``n`` labeled elements.
```
julia> BellNumber(10)
115975
```
$(SIGNATURES)
"""
BellNumber(n::Int) = Nemo.bell(n)
"""
Return the n-th Bell number ``B_n``.
```
julia> V000110(11)
678570
```
$(SIGNATURES)
"""
V000110(n::Int) = Nemo.bell(n)
"""
Return a list of Bell numbers of length len.
```
julia> L000110(10)
[1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147]
```
$(SIGNATURES)
"""
L000110(len::Int) = BellNumberList(len)
"""
The Bell transform transforms an integer sequence into an integer triangle; also known as incomplete Bell polynomials.
Let ``X`` be an integer sequence, then ``B_{n,k}(X) = \\sum_{m=1}^{n-k+1} \\binom{n-1}{m-1} X[m] B_{n-m,k-1}(X)`` where ``B_{0,0} = 1, B_{n,0} = 0`` for ``n≥1, B_{0,k} = 0`` for ``k≥1``.
$(SIGNATURES)
"""
function BellTrans(n::Int, k::Int, X::Array)
    if haskey(CacheBellA, (n, k, X))
        return CacheBellA[(n, k, X)]
    end
    a = fmpz(1); s = fmpz(0)
    if (n == 0) && (k == 0) return a end
    if (n == 0) || (k == 0) return s end
    for m in 1:n-k+1
        s += a * BellTrans(n - m, k - 1, X) * X[m]
        a = div(a * (n - m), m)
    end
    CacheBellA[(n, k, X)] = s
    return s
end
const CacheBellA = Dict{Tuple{Int, Int, Array}, fmpz}()
"""
The Bell transform transforms an integer sequence into an integer triangle; also known as incomplete Bell polynomials.
Let ``F`` be an integer sequence generating function, then ``B_{n,k}(F) = \\sum_{m=1}^{n-k+1} \\binom{n-1}{m-1} F(m) B_{n-m,k-1}(F)`` where ``B_{0,0} = 1, B_{n,0} = 0`` for ``n≥1, B_{0,k} = 0`` for ``k≥1``.
$(SIGNATURES)
"""
function BellTrans(n::Int, k::Int, F::Function)
    if haskey(CacheBellF, (n, k, F))
        return CacheBellF[(n, k, F)]
    end
    a = fmpz(1); s = fmpz(0)
    if (n == 0) && (k == 0) return a end
    if (n == 0) || (k == 0) return s end
    for m in 1:n-k+1
        s += a * BellTrans(n - m, k - 1, F) * F(m - 1)
        a = div(a * (n - m), m)
    end
    CacheBellF[(n, k, F)] = s
    return s
end
const CacheBellF = Dict{Tuple{Int, Int, Function}, fmpz}()
"""
The Bell triangle gathers the results of the Bell transform applied to the initial segments of the input sequence.
Famously the sequence (1,1,1,...) is mapped to the triangle of the Stirling set numbers.
```
julia> ShowAsΔ(BellTriangle(5, k -> 1))
1
0 1
0 1 1
0 1 3 1
0 1 7 6 1
```
$(SIGNATURES)
"""
function BellTriangle(n::Int, seq)
    M = ZTriangle(n)
    i = 1
    for j in 0:n - 1, k in 0:j
        M[i] = BellTrans(j, k, seq)
        i += 1
    end
    return M
end
"""
Return the coefficients of the first ``n`` Abel polynomials.
```
julia> ShowAsΔ(T137452(5))
1
0 1
0 -2 1
0 9 -6 1
0 -64 48 -12 1
```
$(SIGNATURES)
"""
T137452(n::Int) = BellTriangle(n, k -> (-k - 1)^k)
"""
Return the Bell transform of the Bell numbers.
```
julia> ShowAsΔ(T264428(5))
1
0 1
0 1 1
0 2 3 1
0 5 11 6 1
```
$(SIGNATURES)
"""
T264428(n::Int) = BellTriangle(n, BellNumber)
"""
Return the triangle of the coefficients of the Mittag-Leffler polynomials.
```
julia> ShowAsΔ(T137513(5))
1
0 2
0 0 4
0 4 0 8
0 0 32 0 16
```
$(SIGNATURES)
"""
T137513(n::Int) = BellTriangle(n, k -> isOdd(k) ? 0 : 2fac(k))
"""
Return the matrix inverse of coefficients of Bessel polynomials; essentially the same as coefficients of modified Hermite polynomials T096713.
```
julia> ShowAsΔ(T104556(5))
1
0 1
0 -1 1
0 0 -3 1
0 0 3 -6 1
```
$(SIGNATURES)
"""
T104556(n::Int) = BellTriangle(n, k -> k < 2 ? (-1)^k : 0)
"""
Return a triangle of coefficients of Bessel polynomials (better use A132062).
$(SIGNATURES)
"""
T001497(n::Int) = BellTriangle(n, MultiFactorial(2, 1))
"""
Return the triangle of coefficients of Bessel polynomials, also the Sheffer triangle ``(1, 1 - √(1 - 2x))`` (Cf. A001497).
```
julia> ShowAsΔ(T132062(5))
1
0 1
0 1 1
0 3 3 1
0 15 15 6 1
```
$(SIGNATURES)
"""
T132062(n::Int) = BellTriangle(n, MultiFactorial(2, 1))
"""
Return the signed double Pochhammer triangle: expansion of ``x(x-2)(x-4)..(x-2n+2)``.
```
julia> ShowAsΔ(T039683(5))
1
0 1
0 2 1
0 8 6 1
0 48 44 12 1
```
$(SIGNATURES)
"""
T039683(n::Int) = BellTriangle(n, MultiFactorial(2, 2))
"""
Return the Bell transform of the MultiFactorial numbers of type (3,1).
```
julia> ShowAsΔ(T203412(5))
1
0 1
0 1 1
0 4 3 1
0 28 19 6 1
```
$(SIGNATURES)
"""
T203412(n::Int) = BellTriangle(n, MultiFactorial(3, 1))
"""
Return the Bell transform of the MultiFactorial numbers of type (3,2).
```
julia> ShowAsΔ(T004747(5))
1
0 1
0 2 1
0 10 6 1
0 80 52 12 1
```
$(SIGNATURES)
"""
T004747(n::Int) = BellTriangle(n, MultiFactorial(3, 2))
"""
Return the triangle ``3^{n-m}S1(n, m)`` where S1 are the signed Stirling numbers of first kind.
```
julia> ShowAsΔ(T051141(5))
1
0 1
0 3 1
0 18 9 1
0 162 99 18 1
```
$(SIGNATURES)
"""
T051141(n::Int) = BellTriangle(n, MultiFactorial(3, 3))
"""
Return the Bell transform of the quartic factorial numbers.
```
julia> ShowAsΔ(T265606(5))
1
0 1
0 1 1
0 5 3 1
0 45 23 6 1
```
$(SIGNATURES)
"""
T265606(n::Int) = BellTriangle(n, MultiFactorial(4, 1))
"""
Return the triangle of coefficients of numerators in Pade approximation to ``e^x``.
```
julia> ShowAsΔ(T119274(5))
1
0 1
0 2 1
0 12 6 1
0 120 60 12 1
```
$(SIGNATURES)
"""
T119274(n::Int) = BellTriangle(n, MultiFactorial(4, 2))
"""
Return the Bell transform of the MultiFactorial numbers of type (4,3).
```
julia> ShowAsΔ(T000369(5))
1
0 1
0 3 1
0 21 9 1
0 231 111 18 1
```
$(SIGNATURES)
"""
T000369(n::Int) = BellTriangle(n, MultiFactorial(4, 3))
"""
Return the Bell transform of the MultiFactorial numbers of type (4,4).
```
julia> ShowAsΔ(T051142(5))
1
0 1
0 4 1
0 32 12 1
0 384 176 24 1
```
$(SIGNATURES)
"""
T051142(n::Int) = BellTriangle(n, MultiFactorial(4, 4))
# *** BernoulliNumbers.jl ****************
"""
Return the generalized integer Bernoulli numbers ``b_{m}(n) = n \\times ``André``(m, n-1)``.
$(SIGNATURES)
"""
BernoulliInt(m::Int, n::Int) = n == 0 ? ZZ(0) : n * André(m, n - 1)
"""
Return the number of down-up permutations w on ``[n+1]`` such that ``w_2 = 1``.
$(SIGNATURES)
"""
V065619(n::Int) = BernoulliInt(2, n)
"""
Return the generalized integer Bernoulli numbers ``b_{3}(n) = n \\times ``André``_{3}(n-1)``.
$(SIGNATURES)
"""
V281586(n::Int) = BernoulliInt(3, n)
"""
Return the generalized integer Bernoulli numbers ``b_{4}(n) = n \\times `` André``_{4}(n-1)``.
$(SIGNATURES)
"""
V281588(n::Int) = BernoulliInt(4, n)
"""
Return a list of length `len` of the integer Bernoulli numbers ``b_{m}(n)`` using Seidel's boustrophedon algorithm.
$(SIGNATURES)
"""
function BernoulliIntList(m::Int, len::Int)
    len ≤ 0 && return fmpz[]
    R = zeros(ZZ, len)
    len == 1 && return R
    R[2] = 1
    len == 2 && return R
    A = zeros(ZZ, len)
    A[1] = 1; A[2] = 1
    for n in 1:len - 2
        if n % m ≠ 0
            for i in n:-1:1 A[i] += A[i + 1] end
            C = A[1]
        else
            C = 0
            for i in 1:(n + 2) A[i], C = C, A[i]; C = A[i] - C end
        end
        R[n + 2] = C
    end
    R
end
"""
Computes a list of length `len` of the integer Bernoulli numbers ``b_{2}(n)`` using Seidel's boustrophedon algorithm.
$(SIGNATURES)
"""
function L065619(len::Int)
    len ≤ 0  && return fmpz[]
    R  = zeros(ZZ, len)
    len == 1 && return R[0]
    len == 2 && (R[0, 1] = 1; return R)
    A = Dict{Int,fmpz}(-1 => 1, 0 => 0)
    k = 0; e = 1
    for i in 0:len - 1
        Am = 0; A[k + e] = 0; e = -e
        for j in 0:i
            Am += A[k]; A[k] = Am; k += e
        end
        j = e < 0 ? div(-i, 2) : div(i, 2)
        R[i+1] = A[j]
    end
    R
end
"""
Return the rational Bernoulli number ``B_n``  (cf. A027641/A027642).
$(SIGNATURES)
"""
function Bernoulli(n::Int)
    isOdd(n) && (n == 1 ? (return fmpq(1, 2)) : (return fmpq(0, 1)))
    n == 0 && return fmpq(1, 1)
    denom = ^(ZZ(4), n) - ^(ZZ(2), n)
    fmpq(BernoulliInt(2, n), denom)
end
"""
Return a list of the first `len` Bernoulli numbers ``B_n`` (cf. A027641/A027642).
$(SIGNATURES)
"""
function BernoulliList(len::Int)
    if len ≤ 0 return fmpq[] end
    R = zeros(QQ, len)
    R[1] = fmpq(1, 1); len == 1 && return R
    R[2] = fmpq(1, 2); len == 2 && return R
    A = Dict{Int,fmpz}(0 => 1, -2 => 0, -1 => 1, 1 => 0)
    a = fmpz(12); b = fmpz(240)
    k = e = 1
    for i in 2:len - 1
        Am = 0; A[k + e] = 0; e = -e
        for j in 0:i
            Am += A[k]; A[k] = Am; k += e
        end
        if e > 0
            R[i + 1] = fmpq(0, 1)
        else
            d = i >> 1
            R[i + 1] = isEven(d) ? fmpq(-A[-d], a) : fmpq(A[-d], a)
            a, b = b, b << 4 + b << 2 - a << 6
        end
    end
    R
end
"""
Return the numerator of the Bernoulli number ``B_n``.
$(SIGNATURES)
"""
function V027641(n::Int)
    isOdd(n) && (n == 1 ? (return ZZ(-1)) : return ZZ(0))
    n == 0 && return ZZ(1)
    denom = ^(ZZ(4), n) - ^(ZZ(2), n)
    Nemo.numerator(BernoulliInt(2, n) // denom)
end
"""
Return denominator(Bernoulli ``_{n+1}(x) - `` Bernoulli ``_{n+1})``.
$(SIGNATURES)
"""
function V195441(n::Int)
    n < 4 && return ZZ([1, 1, 2, 1][n + 1])
    P = Primes(2, div(n + 2, 2 + n % 2))
    ∏([p for p in P if p ≤ sum(digits(n + 1, base=Int(p)))])
end
# *** BinaryInteger.jl ****************
"""
Return the length of the binary extension of an integer ``n``, which is defined as ``0`` if ``n = 0`` and for ``n > 0`` as ``⌊ log _2(n) ⌋ + 1``.
$(SIGNATURES)
"""
BinaryIntegerLength(n) = n == 0 ? 0 : Int(floor(log2(n))) + 1
"""
Alias for the function BinaryIntegerLength.
$(SIGNATURES)
"""
Bil(n) = BinaryIntegerLength(n)
"""
Return ``n`` Bil``(n) - 2^{Bil(n)}`` where Bil``(n)`` is the binary integer length of ``n``.
$(SIGNATURES)
"""
V295513(n) = n*Bil(n) - 2^Bil(n)
"""
Maximal number of comparisons for sorting ``n`` elements by binary insertion.
$(SIGNATURES)
"""
V001855(n) = V295513(n) + 1
"""
Return the sum of lengths of binary expansions of ``0`` through ``n``.
$(SIGNATURES)
"""
V083652(n) = V295513(n+1) + 2
"""
Recurrence ``a(n) = a(n-1) + ⌊ a(n-1)/(n-1) ⌋ + 2`` for ``m ≥ 2`` and ``a(1) = 1``.
$(SIGNATURES)
"""
V033156(n) = V295513(n) + 2n
"""
Binary entropy function: ``a(n) = n + `` min ``( a(k) + a(n-k) : 1 ≤ k ≤ n-1 )`` for ``n > 1,`` and ``a(1) = 0``.
$(SIGNATURES)
"""
V003314(n) = V295513(n) + n
"""
Binary entropy: ``a(n) = n +`` min ``{ a(k) + a(n-k) : 1 ≤ k ≤ n-1 }.``
$(SIGNATURES)
"""
V054248(n) = V295513(n) + n + rem(n, 2)
"""
Minimum total number of comparisons to find each of the values ``1`` through ``n`` using a binary search with ``3``-way comparisons.
$(SIGNATURES)
"""
V097383(n) = V295513(n+1) - div(n-1, 2)
"""
Partial sums of the sequence ``⌊ \\log_2(n) ⌋``.
$(SIGNATURES)
"""
V061168(n) = V295513(n+1) - n + 1
"""
Partial sums of the sequence of length of the binary expansion of ``2n+1``.
$(SIGNATURES)
"""
V123753(n) = V295513(n+1) + n + 2
# *** BinaryQF.jl ****************
"""
Return integers that are represented by the binary quadratic form ``a x^2 + b xy + c y^2`` over Z. Parameter 'subset' is in {"positive", "primitively", "prime"}. Use it only as an intern function.
$(SIGNATURES)
"""
function binaryQF(a::Int, b::Int, c::Int, bound = 100::Int, subset = "positive", verbose = false)
    α, β, γ = a, b, c
    discriminant() = fmpz(β^2 - 4 * α * γ)
    isreduced() = (-α < β ≤ α < γ) || (fmpz(0) ≤ β ≤ α == γ)
    function roots(a::Int, b::Int, c::Int, n::Int, y::Int)
    throw(ErrorException("not yet implemented"))
end
    function sqr_disc(M, primitively = false)
    d = discriminant()
    d == 0 && throw(ValueError("discriminant must not be zero"))
    a, b, c = α, β, γ
    (a == 0 && c == 0) && return [b * n for n in 1:div(M, abs(b))]
    D = isqrt(d)
    if a == 0
        a, c = c, 0
    end
    k = 2 * D; m = 4 * a * D
    u = b + D; v = b - D
    S = fmpz[]
    for n in 1:M
        h = fmpz(4 * a * n)  # a <> 0 and n <> 0
        for t in Divisors(h) # returns fmpz
            g = fmpz(div(h, t))
            if rem(g - t, k) == 0 && rem(g * u - t * v, m) == 0
                if primitively
                    y = div(g - t, k)
                    R = roots(a, b, c, n, y)
                    if isPrimeTo(R[1], y)
                        push!(S, n)
                        break
                    end
                else
                    push!(S, n)
                    break
                end
            end
        end
    end
    sort([s for s in Set(S)])
end
    function imag_prime(M)
    throw(ErrorException("not yet implemented"))
end
    function imag_primitively(M)
    a, b, c = α, β, γ
    d = c - div(b * b, 4 * a)
    A = []
    for y in 0:isqrt(div(M, d))
        r = y * b / (2 * a)
        s = sqrt((M - d * y * y) / a)
        for x in Int(round(ceil(-s - r))):Int(round(floor(s - r)))
            isPrimeTo(x, y) && push!(A, a * x^2 + b * x * y + c * y^2)
        end
    end
    sort([s for s in Set(A)])
end
    function imag_positive(M)
    throw(ErrorException("not yet implemented"))
end
    function primitive_reps(a, h, b, M, S)
    if a ≤ M
        push!(S, a)
        if b ≤ M
            push!(S, b)
            if a ≤ (M - b) && h ≤ (M - a - b)
                a ≤ (M - a - h) && primitive_reps(a, h + 2 * a, a + b + h, M, S)
                b ≤ (M - b - h) && primitive_reps(a + b + h, h + 2 * b, b, M, S)
            end
        end
    end
end
    function positive_primitives(bound, primitively)
    a, b, c = α, β, γ
    S = fmpz[]
    while true
        new_val = a + b + c
        if new_val > 0
            primitive_reps(a, b + 2 * a, new_val, bound, S)
            b += 2 * c
            a = new_val
        else
            if new_val < 0
                b += 2 * a
                c = new_val
            end
        end
        if a == α && b == β && c == γ break end
    end
    if ! primitively
        X = fmpz[]
        for p in S
            q = t = 1
            while q ≤ bound
                push!(X, q)
                q = t * t * p
                t += 1
            end
        end
        S = X
    end
    sort([s for s in Set(S)])
end
    function reduce_real()
    d = discriminant()
    isSquare(d) && throw(ValueError("form must not have square discriminant"))
    droot = isqrt(d)
    a, b, c = α, β, γ
    while a ≤ 0 || c ≥ 0 || b ≤ abs(a + c)
        cAbs = c
        if cAbs < 0  cAbs *= -1 end
        delta = div(b + droot, 2 * cAbs)
        if c < 0  delta *= -1 end
        aa = c
        bb = 2 * c * delta - b
        cc = c * delta * delta - b * delta + a
        a, b, c = aa, bb, cc
    end
    return [a, b, c]
end
    function reduce_imag()
    a, b, c = α, β, γ
    if a < 0
        a, b, c = -a, -b, -c
    end
    d = discriminant()
    while true
        A = (a == c && b < 0) || (c < a)
        L = (-a == b && a < c) || (a < abs(b))
        !(A || L) && break
        if A
            a, b, c = c, -b, a
        end
        if L
            b -= 2 * a * div(b, 2 * a)
            if abs(b) > a  b -= 2 * a end
            c = div(b * b - d, 4 * a)
        end
    end
    return [a, b, c]
end
    function reduced_form()
    isreduced() && return [α, β, γ]
    if discriminant() ≥ 0
        return reduce_real()
    else
        return reduce_imag()
    end
end
    prime = false || subset == "prime"
    primitively = false || subset == "primitively"
    d = discriminant()
    d == 0 && throw(ValueError("discriminant must not be 0"))
    a, b, c = α, β, γ
    if verbose
        println("Original form [", a, ", ", b, ", ", c, "] with discriminant ", d)
    end
    if isSquare(d)
        verbose && println("Square discriminant!")
        if prime primitively = false end # for efficiency
        pp = sqr_disc(bound, primitively)
        if prime pp = [m for m in pp if isPrime(m)] end
    else
        α, β, γ = reduced_form()
        verbose && println("Reduced form  [", α, ", ", β, ", ", γ, "]")
        if d < 0
            if prime
                pp = imag_prime(bound)
            else
                if primitively
                    pp = imag_primitively(bound)
                else
                    pp = imag_positive(bound)
                end
            end
        else # d > 0 and not square
            if prime
                primitively = true
            end # for efficiency
            pp = positive_primitives(bound, primitively)
            if prime pp = [m for m in pp if isPrime(m)] end
        end
    end
    if verbose
        msg0 = prime ? " primes " : " positive integers "
        msg1 = primitively ? "primitively " : ""
        msg2 = "represented up to "
        println("There are ", length(pp), msg0, msg1, msg2, bound)
    end
    pp
end # binary_QF
"""
Return positive numbers of the form ``n = x^2-3y^2`` of discriminant 12.
$(SIGNATURES)
"""
L084916(bound::Int) = binaryQF(1, 0, -3, bound)
"""
Return positive numbers that are primitively represented by the indefinite quadratic form ``x^2 - 3y^2`` of discriminant 12.
$(SIGNATURES)
"""
L243655(bound::Int) = binaryQF(1, 0, -3, bound, "primitively")
"""
Return primes congruent to 1 (mod 12).
$(SIGNATURES)
"""
L068228(bound::Int) = binaryQF(1, 0, -3, bound, "prime")
"""
Return positive numbers of the form ``x^2+xy-2y^2``.
$(SIGNATURES)
"""
L242660(bound::Int) = binaryQF(1, 1, -2, bound)
"""
Return positive numbers primitively represented by the binary quadratic form (1, 1, -2).
$(SIGNATURES)
"""
L244713(bound::Int) = binaryQF(1, 1, -2, bound, "primitively")
"""
Return primes of the form ``6m + 1``.
$(SIGNATURES)
"""
L002476(bound::Int) = binaryQF(1, 1, -2, bound, "prime")
"""
Return positive numbers of the form ``x^2 - 2y^2`` with integers ``x, y`` (discriminant is 8).
$(SIGNATURES)
"""
L035251(bound::Int) = binaryQF(1, 0, -2, bound)
"""
Return mumbers n such that 2 is a square mod n.
$(SIGNATURES)
"""
L057126(bound::Int) = binaryQF(1, 0, -2, bound, "primitively")
"""
Return primes p such that 2 is a square mod p; or, primes congruent to ``{1, 2, 7}`` mod ``8``.
$(SIGNATURES)
"""
L038873(bound::Int) = binaryQF(1, 0, -2, bound, "prime")
"""
Return positive numbers of the form ``x^2+xy-y^2``; or, of the form ``5x^2-y^2``.
$(SIGNATURES)
"""
L031363(bound::Int) = binaryQF(1, 1, -1, bound) # "positive"
"""
Return positive numbers represented by the integer binary quadratic form ``x^2+xy-y^2`` with ``x`` and ``y`` relatively prime.
$(SIGNATURES)
"""
L089270(bound::Int) = binaryQF(1, 1, -1, bound, "primitively")
"""
Return primes represented by the integer binary quadratic form ``x^2+xy-y^2``.
$(SIGNATURES)
"""
L141158(bound::Int) = binaryQF(1, 1, -1, bound, "prime")
"""
Return primes congruent to ``{0, 1, 4}`` mod 5 (cf. also `[A141158]`).
$(SIGNATURES)
"""
L038872(bound::Int) = binaryQF(1, 1, -1, bound, "prime")
"""
Return positive integers not congruent to 2 mod 4; regular numbers modulo 4.
$(SIGNATURES)
"""
L042965(bound::Int) = binaryQF(1, 0, -1, bound) # "positive"
"""
Return numbers that are congruent to ``{0, 1, 3, 5, 7}`` mod 8. Positive integers represented by the binary quadratic form ``x^2-y^2`` with ``x`` and ``y`` relatively prime.
$(SIGNATURES)
"""
L047486(bound::Int) = binaryQF(1, 0, -1, bound, "primitively")
"""
Return positive integers of the form ``x^2 + xy + y^2`` (Loeschian numbers).
$(SIGNATURES)
"""
L003136(bound::Int) = binaryQF(1, 1, 1, bound) # "positive"
"""
Return positive integers that are primitively represented by ``x^2 + xy + y^2``.
$(SIGNATURES)
"""
L034017(bound::Int) = binaryQF(1, 1, 1, bound, "primitively")
"""
Return primes that are represented by ``x^2 + xy + y^2`` (generalized cuban primes).
$(SIGNATURES)
"""
L007645(bound::Int) = binaryQF(1, 1, 1, bound, "prime")
"""
Return positive integers that are the sum of 2 squares.
$(SIGNATURES)
"""
L001481(bound::Int) = binaryQF(1, 0, 1, bound) # "positive"
"""
Return numbers ``n`` that are primitively represented by ``x^2 + y^2``. Also numbers n such that ``√(-1)`` mod ``n`` exists.
$(SIGNATURES)
"""
L008784(bound::Int) = binaryQF(1, 0, 1, bound, "primitively")
"""
Return primes of form ``x^2 + y^2``; or primes congruent to 1 or 2 modulo 4.
$(SIGNATURES)
"""
L002313(bound::Int) = binaryQF(1, 0, 1, bound, "prime")
"""
Return Pythagorean primes: primes of form ``4n + 1``.
$(SIGNATURES)
"""
L002144(bound::Int) = binaryQF(1, 0, 1, bound, "prime")
"""
Return positive integers of the form ``x^2+xy+2y^2`` with ``x`` and ``y`` integers. See also A035248.
$(SIGNATURES)
"""
L028951(bound::Int) = binaryQF(1, 1, 2, bound) # "positive"
"""
Return positive numbers primitively represented by the binary quadratic form (1, 1, 2).
$(SIGNATURES)
"""
L244779(bound::Int) = binaryQF(1, 1, 2, bound, "primitively")
"""
Return primes represented by the binary quadratic form (1, 1, 2). Primes congruent to ``{0, 1, 2, 4}`` mod 7.
$(SIGNATURES)
"""
L045373(bound::Int) = binaryQF(1, 1, 2, bound, "prime")
"""
Return primes of form ``x^2+7*y^2``.
$(SIGNATURES)
"""
L033207(bound::Int) = binaryQF(1, 1, 2, bound, "prime")
"""
Return integers of form ``x^2 + 2y^2``.
$(SIGNATURES)
"""
L002479(bound::Int) = binaryQF(1, 0, 2, bound)
"""
Return positive integers primitively represented by ``x^2 + 2y^2``.
$(SIGNATURES)
"""
L057127(bound::Int) = binaryQF(1, 0, 2, bound, "primitively")
"""
Return primes of form ``x^2+2*y^2``. Primes congruent to ``{1, 2, 3}`` mod 8.
$(SIGNATURES)
"""
L033203(bound::Int) = binaryQF(1, 0, 2, bound, "prime")
"""
Return odd primes of form ``x^2+2y^2``. Primes congruent to ``{1, 3}`` mod 8.
$(SIGNATURES)
"""
L033200(bound::Int) = binaryQF(1, 0, 2, bound, "prime")
"""
Return positive numbers represented by the binary quadratic form (1, 1, 3). (See also A028954.)
$(SIGNATURES)
"""
L035247(bound::Int) = binaryQF(1, 1, 3, bound) # "positive"
"""
Return positive numbers primitively represented by the binary quadratic form (1, 1, 3).
$(SIGNATURES)
"""
L244780(bound::Int) = binaryQF(1, 1, 3, bound, "primitively")
"""
Return primes of form ``x^2+xy+3y^2``, discriminant -11.
$(SIGNATURES)
"""
L056874(bound::Int) = binaryQF(1, 1, 3, bound, "prime")
"""
Return positive numbers primitively represented by the binary quadratic form (1, 0, 3).
$(SIGNATURES)
"""
L244819(bound::Int) = binaryQF(1, 0, 3, bound, "primitively")
"""
Return positive integers of the form ``x^2+6xy-3y^2``.
$(SIGNATURES)
"""
L243168(bound::Int) = binaryQF(1, 6, -3, bound)
"""
Return positive numbers primitively represented by the binary quadratic form (1, 6, -3).
$(SIGNATURES)
"""
L244291(bound::Int) = binaryQF(1, 6, -3, bound, "primitively")
"""
Return primes of the form ``8n+7``, that is, primes congruent to -1 mod 8.
$(SIGNATURES)
"""
L007522(bound::Int) = binaryQF(-1, 4, 4, bound, "prime")
# *** CarmichaelNumbers.jl ****************
"""
Is ``n`` a Carmichael/Šimerka number?
$(SIGNATURES)
"""
function isCarmichael(n)
    (n == 1 || isEven(n) || isPrime(n)) && return false
    factors = Factors(n)
    for f in factors
        (f[2] > 1 || (n - 1) % (f[1] - 1) != 0) && return false
    end
    return true
end
"""
Iterate over the first n Carmichael/Šimerka numbers.
$(SIGNATURES)
"""
I002997(n) = takefirst(isCarmichael, n)
"""
Iterate over the Carmichael/Šimerka numbers which do not exceed n.
$(SIGNATURES)
"""
F002997(n) = filter(isCarmichael, 1:n)
"""
Return the first n Carmichael/Šimerka numbers in an array.
$(SIGNATURES)
"""
L002997(n) = collect(I002997(n))
# *** ClausenNumbers.jl ****************
"""
Return the Clausen number ``C_n`` which is the denominator of the Bernoulli number ``B_{2n}``.
$(SIGNATURES)
"""
function ClausenNumber(n::Int)
    n == 0 && return ZZ(1)
    m = [d + 1 for d in Divisors(2n)]
    ∏([q for q in m if isPrime(q)])
end
"""
Return the list of length len of Clausen numbers which are the denominators of the Bernoulli numbers ``B_{2n}``.
$(SIGNATURES)
"""
function ClausenNumberList(len::Int)
    len ≤ 0 && return fmpz[]
    A = fill(ZZ(2), len);  A[1] = 1
    m = len - 1
    m == 0 && return A
    for p in Primes(3, 2m + 1)
        r = div(p - 1, 2)
        for k in range(r, step=r, length=div(m, r))
            A[k+1] *= p
        end
    end
    A
end
"""
Return the Clausen number ``C(n)`` which is the denominator of the Bernoulli number ``B_{2n}``.
$(SIGNATURES)
"""
V002445(n::Int) = ClausenNumber(n)
"""
Return the list of length len of Clausen numbers which are the denominators of the Bernoulli numbers ``B_{2n}``.
$(SIGNATURES)
"""
L002445(len::Int) = ClausenNumberList(len)
"""
Return the denominator of Bernoulli number ``B_n``.
$(SIGNATURES)
"""
function V027642(n::Int)
    isEven(n) && return ClausenNumber(div(n, 2))
    n == 1 && return ZZ(2)
    return ZZ(1)
end
# *** CombinationsIterator.jl ****************
struct combinations
    n::Int
    t::Int
end
function Base.iterate(c::combinations, s=[min(c.t - 1, i) for i in 1:c.t])
    if c.t == 0 # special case to generate 1 result for t==0
        isempty(s) && return (s, [1])
        return
    end
    for i in c.t:-1:1
        s[i] += 1
        if s[i] > (c.n - (c.t - i))
            continue
        end
        for j in i + 1:c.t
            s[j] = s[j - 1] + 1
        end
        break
    end
    s[1] > c.n - c.t + 1 && return
    (s, s)
end
Base.length(c::combinations) = binomial(c.n, c.t)
Base.eltype(::Type{combinations}) = Vector{Int}
"""
Generate all Combinations of ``n`` elements from an indexable object ``a``. Because the number of Combinations can be very large, this function returns an iterator object.
Use collect(Combinations(a, n)) to get an array of all Combinations.
$(SIGNATURES)
"""
function Combinations(a, t::Integer)
    if t < 0
        t = length(a) + 1
    end
    reorder(c) = [a[ci] for ci in c]
    (reorder(c) for c in combinations(length(a), t))
end
"""
Generate Combinations of the elements of ``a`` of all orders. Chaining of order iterators is eager, but the sequence at each order is lazy.
$(SIGNATURES)
"""
Combinations(a) = Iterators.flatten([Combinations(a, k) for k = 1:length(a)])
# *** Compositions.jl ****************
"""
Recurrence for `A097805`, the compositions of ``n`` with ``k`` parts.
$(SIGNATURES)
"""
function R097805(n, k, prevrow::Function)
    k == 0 && return ZZ(k^n)
    prevrow(k - 1) + prevrow(k)
end
"""
Iterates over the first ``n`` rows of A097805.
$(SIGNATURES)
"""
I097805(n) = RecTriangle(n, R097805)
"""
Lists the first ``n`` rows of A097805 by concatinating. This is the format for submissions to the OEIS.
$(SIGNATURES)
"""
L097805(n) = vcat(I097805(n)...)
"""
Return the triangular array as a square matrix.
$(SIGNATURES)
"""
M097805(dim) = fromΔ(L097805(dim))
"""
Return row ``n`` of A097805 based on the iteration I097805(n).
$(SIGNATURES)
"""
V097805(n) = nth(I097805(n+1), n+1)
# *** Counts.jl ****************
"""
Return a list of length len of integers ``≥ 0`` which are isA.
$(SIGNATURES)
"""
function List(len, isA::Function)
    len ≤ 0 && return fmpz[]
    j, c = Int(0), Int(1)
    A = fill(ZZ(0), len)
    while c <= len
        if isA(j)
            A[c] = fmpz(j)
            c += 1
        end
        j += 1
    end
    A
end
"""
Iverson brackets.
$(SIGNATURES)
"""
ι(b) = b ? 1 : 0
"""
Inverse Iverson brackets.
$(SIGNATURES)
"""
ιι(n) = n == 0 ? true : false
"""
Return a iterator of length n which has value 1 if isA(i) is true and otherwise 0.
$(SIGNATURES)
"""
function Indicators(n, isA)
    (ι(isA(i)) for i in 0:n - 1)
end
"""
Return a list of length len which gives the numbers of integers ≤ n which are isA. Integers start at ``n=0``.
```
julia> CountList(8, isPrime)
[0, 0, 1, 2, 2, 3, 3, 4]
```
$(SIGNATURES)
"""
CountList(len::Int, isA::Function) = Accumulate(Indicators(len, isA))
"""
Return the numbers of integers ≤ n which are isA. Integers start at ``n=0``.
```
julia> Count(8, isPrime)
4
```
$(SIGNATURES)
"""
function Count(n, isA)
    count(!iszero, Indicators(n + 1, isA))
end
"""
Return a SeqArray listing the values satisfying the predicate isA for arguments ``0 ≤ x ≤ `` bound.
```
julia> FindUpTo(7, IsPrime)
[2, 3, 5, 7]
```
$(SIGNATURES)
"""
function FindUpTo(bound, isA)
    bound < 0 && return fmpz[]
    filter(isA, 0:bound)
end
"""
Return the first ``n`` numbers satisfying the predicate isA.
$(SIGNATURES)
"""
takefirst(isA, n) = Iterators.take(Iterators.filter(isA, Iterators.countfrom(1)), n)
"""
Return a iterator listing the values satisfying the predicate isA for arguments in ``0 ≤ n ≤ bound .``
$(SIGNATURES)
"""
function IterateUpTo(bound, isA)
    (i for i in 0:bound if isA(i))
end
"""
Returns an integer which is the highest index in `b` for the value `a`. Whenever `a` is not a member of `b` it returns -1.
```
julia> L = List(10, IsPrime); IndexIn(13, L)
5
```
$(SIGNATURES)
"""
function IndexIn(a, b::AbstractArray)
    bdict = Dict(zip(b, 0:length(b)))
    get(bdict, fmpz(a), -1)
end
"""
Return the Nth integer which is isA. (For N ≤ 0 return 0.)
```
julia> Nth(7, isPrime)
17
```
$(SIGNATURES)
"""
function Nth(N, isA::Function)
    N ≤ 0 && return 0
    n, c = Int(0), Int(0)
    while c < N
        i = isA(n)
        i && (c += 1)
        n += 1
    end
    n - 1
end
"""
Return the cumulative sum of an SeqArray.
$(SIGNATURES)
"""
function Accumulate(A)
    R = fill(ZZ(0), length(A))
    i, acu = 1, 0
    for a in A
        acu += a
        R[i] = acu
        i += 1
    end
    R
end
"""
Return the smallest list of indicators of isA with ∑(A) = count.
```
julia> IndicatorsFind(7, isPrime)
[0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1]
```
$(SIGNATURES)
"""
function IndicatorsFind(count, isA::Function)
    count ≤ 0 && return []
    n, c = Int(0), Int(0)
    A = Int[]
    while c < count
        i = isA(n)
        i && (c += 1)
        push!(A, ι(i))
        n += 1
    end
    A
end
"""
Return the first integer ``n ≥ 0`` such that isA(n) = true.
```
julia> First(isPrime)
2
```
$(SIGNATURES)
"""
function First(isA::Function)
    n = 0
    while !isA(n)
        n += 1
    end
    n
end
First(A::Array{Int}) = A == [] ? nothing : first(A)
"""
Return the element at the end of the list A if A is not empty, 0 otherwise.
$(SIGNATURES)
"""
Last(A) = A == [] ? "undef" : A[end]
"""
Trick described by David Hilbert in a 1924 lecture "Über das Unendliche".
$(SIGNATURES)
"""
HilbertHotel(guest, hotel) = prepend!(hotel, guest)
"""
Return largest ``0 < k < n`` such that isA(k) = true or nothing if no such ``k`` exists.
```
julia> Previous(7, isPrime)
5
```
$(SIGNATURES)
"""
function Previous(n, isA::Function)
    n == nothing && return First(isA)
    while true
        n -= 1
        isA(n) && break
        n < 0 && return First(isA)
    end
    n
end
"""
Return least ``k > n ≥ 0`` such that isA(k) = true. NOTE: It is assumed that such a ``k`` exists! (If not, the function will run forever.)
```
julia> Next(7, isPrime)
11
```
$(SIGNATURES)
"""
function Next(n, isA::Function)
    ((n ≤ 0) || (n == nothing)) && return First(isA)
    while true
        n += 1
        isA(n) && break
    end
    n
end
"""
Return a list of composite numbers of length len. (Numbers which have more than one prime divisor.)
```
julia> L002808(8)
[4, 6, 8, 9, 10, 12, 14, 15]
```
$(SIGNATURES)
"""
L002808(len) = List(len, isComposite)
"""
Return a list of the number of composite numbers ``≤ n``.
```
julia> L065855(8)
[0, 0, 0, 0, 1, 1, 2, 2]
```
$(SIGNATURES)
"""
L065855(len) = CountList(len, isComposite)
"""
Return a list of squarefree numbers of length len. (Numbers which are not divisible by a square greater than 1.)
```
julia> L005117(8)
[1, 2, 3, 5, 6, 7, 10, 11]
```
$(SIGNATURES)
"""
L005117(len) = List(len, isSquareFree)
"""
Return a list of the number of squarefree numbers ``< n``.
```
julia> L013928(8)
[0, 1, 2, 3, 3, 4, 5, 6]
```
$(SIGNATURES)
"""
L013928(len) = CountList(len, isSquareFree)
"""
Return a list of powers of primes of length len. (Numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 0``.)
```
julia> L000961(8)
[1, 2, 3, 4, 5, 7, 8, 9]
```
$(SIGNATURES)
"""
L000961(len) = List(len, isPowerOfPrimes)
"""
Return the number of powers of primes ``≤ n``. (Powers of primes are numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 0``.)
```
julia> L065515(8)
[0, 1, 2, 3, 4, 5, 5, 6]
```
$(SIGNATURES)
"""
L065515(len) = CountList(len, isPowerOfPrimes)
"""
Return a list of prime powers of length len. (Numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 1``.)
```
julia> L246655(8)
[2, 3, 4, 5, 7, 8, 9, 11]
```
$(SIGNATURES)
"""
L246655(len) = List(len, isPrimePower)
"""
Return a list of the number of prime powers ``≤ n`` with exponents ``k ≥ 1``.
```
julia> L025528(8)
[0, 0, 1, 2, 3, 4, 4, 5]
```
$(SIGNATURES)
"""
L025528(len) = CountList(len, isPrimePower)
"""
Return a list of perfect powers of length len. (Numbers of the form ``p^k`` where ``p`` is a prime and ``k ≥ 2``.
```
julia> L246547(8)
[4, 8, 9, 16, 25, 27, 32, 49]
```
$(SIGNATURES)
"""
L246547(len) = List(len, isPerfectPower)
"""
Return a list of the number of prime powers ``≤ n`` with exponents ``k ≥ 2``.
```
julia> L069637(8)
[0, 0, 0, 0, 1, 1, 1, 1]
```
$(SIGNATURES)
"""
L069637(len) = CountList(len, isPerfectPower)
"""
Return the largest prime in ``N`` (the semiring of natural numbers including zero) less than n for ``n ≥ 0``.
(The `prev_prime` function of Mathematica, Maple, Magma and SageMath.)
$(SIGNATURES)
"""
A007917(n::Int) = Previous(n, isPrime)
"""
Return the largest prime in ``Z`` (the ring of all integers) less than ``n`` for ``n ≥ 0`` (cf. A007917).
$(SIGNATURES)
"""
PreviousPrime(n::Int) = n ∈ [0, 1, 2] ? -2 : Previous(n - 1, isPrime)
"""
Return least prime ``> n``. The next_prime function of Mathematica, Maple, Magma and SageMath (cf. A151800).
$(SIGNATURES)
"""
NextPrime(n::Int) = Next(n, isPrime)
"""
Return least prime ``> n``. The `next_prime` function of Mathematica, Maple, Magma and SageMath.
$(SIGNATURES)
"""
A151800(n::Int) = Next(n, isPrime)
"""
Return the list of number of primes ``≤ n`` for ``n ≥ 0``.
```
julia> PrimePiList(8)
[0, 0, 1, 2, 2, 3, 3, 4]
```
$(SIGNATURES)
"""
PrimePiList(len::Int) = CountList(len, isPrime)
"""
Return the list of number of primes ``≤ n`` for ``n ≥ 0``.
```
julia> L000720(8)
[0, 0, 1, 2, 2, 3, 3, 4]
```
$(SIGNATURES)
"""
L000720(len::Int) = PrimePiList(len)
"""
Return the index of the least prime not dividing ``n``.
$(SIGNATURES)
"""
function A257993(n::Int)
    c, p = 1, 2
    while n % p == 0
        p = NextPrime(p)
        c += 1
    end
    c
end
# *** DedekindEta.jl ****************
"""
Compute the ``q``-expansion to length len of the Dedekind ``η`` function (without
the leading factor ``q^{1/24}``) raised to the power ``r``, i.e.
``{(q^{-1/24} η(q))^r = ∏_{k ≥ 1} (1 - q^k)^r.}`` In particular, ``r = -1`` returns the generating function of the Partition function ``p(k)`` and ``r = 24`` gives the Ramanujan tau function ``τ(k)``.
$(SIGNATURES)
"""
function DedekindEtaPowers(len::Int, r::Int)
    len ≤ 0 && return fmpz[]
    R, x = PolynomialRing(ZZ, "x")
    e = eta_qexp(r, len, x)
    [coeff(e, j) for j in 0:len - 1]
end
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)``.
$(SIGNATURES)
"""
L010815(len::Int) = DedekindEtaPowers(len, 1)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^2``.
$(SIGNATURES)
"""
L002107(len::Int) = DedekindEtaPowers(len, 2)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^3``.
$(SIGNATURES)
"""
L010816(len::Int) = DedekindEtaPowers(len, 3)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^4``.
$(SIGNATURES)
"""
L000727(len::Int) = DedekindEtaPowers(len, 4)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^5``.
$(SIGNATURES)
"""
L000728(len::Int) = DedekindEtaPowers(len, 5)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^6``.
$(SIGNATURES)
"""
L000729(len::Int) = DedekindEtaPowers(len, 6)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^7``.
$(SIGNATURES)
"""
L000730(len::Int) = DedekindEtaPowers(len, 7)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^8``.
$(SIGNATURES)
"""
L000731(len::Int) = DedekindEtaPowers(len, 8)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^9``.
$(SIGNATURES)
"""
L010817(len::Int) = DedekindEtaPowers(len, 9)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{10}``.
$(SIGNATURES)
"""
L010818(len::Int) = DedekindEtaPowers(len, 10)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{11}``.
$(SIGNATURES)
"""
L010819(len::Int) = DedekindEtaPowers(len, 11)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{12}``.
$(SIGNATURES)
"""
L000735(len::Int) = DedekindEtaPowers(len, 12)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{13}``.
$(SIGNATURES)
"""
L010820(len::Int) = DedekindEtaPowers(len, 13)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{14}``.
$(SIGNATURES)
"""
L010821(len::Int) = DedekindEtaPowers(len, 14)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{15}``.
$(SIGNATURES)
"""
L010822(len::Int) = DedekindEtaPowers(len, 15)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{16}``.
$(SIGNATURES)
"""
L000739(len::Int) = DedekindEtaPowers(len, 16)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{17}``.
$(SIGNATURES)
"""
L010823(len::Int) = DedekindEtaPowers(len, 17)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{18}``.
$(SIGNATURES)
"""
L010824(len::Int) = DedekindEtaPowers(len, 18)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{19}``.
$(SIGNATURES)
"""
L010825(len::Int) = DedekindEtaPowers(len, 19)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{20}``.
$(SIGNATURES)
"""
L010826(len::Int) = DedekindEtaPowers(len, 20)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{21}``.
$(SIGNATURES)
"""
L010827(len::Int) = DedekindEtaPowers(len, 21)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{22}``.
$(SIGNATURES)
"""
L010828(len::Int) = DedekindEtaPowers(len, 22)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{23}``.
$(SIGNATURES)
"""
L010829(len::Int) = DedekindEtaPowers(len, 23)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{24}``.
$(SIGNATURES)
"""
L000594(len::Int) = DedekindEtaPowers(len, 24)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{25}``.
$(SIGNATURES)
"""
L010830(len::Int) = DedekindEtaPowers(len, 25)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{26}``.
$(SIGNATURES)
"""
L010831(len::Int) = DedekindEtaPowers(len, 26)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{27}``.
$(SIGNATURES)
"""
L010832(len::Int) = DedekindEtaPowers(len, 27)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{28}``.
$(SIGNATURES)
"""
L010833(len::Int) = DedekindEtaPowers(len, 28)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{29}``.
$(SIGNATURES)
"""
L010834(len::Int) = DedekindEtaPowers(len, 29)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{30}``.
$(SIGNATURES)
"""
L010835(len::Int) = DedekindEtaPowers(len, 30)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{31}``.
$(SIGNATURES)
"""
L010836(len::Int) = DedekindEtaPowers(len, 31)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{32}``.
$(SIGNATURES)
"""
L010837(len::Int) = DedekindEtaPowers(len, 32)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{40}``.
$(SIGNATURES)
"""
L010840(len::Int) = DedekindEtaPowers(len, 40)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{44}``.
$(SIGNATURES)
"""
L010838(len::Int) = DedekindEtaPowers(len, 44)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{48}``.
$(SIGNATURES)
"""
L010839(len::Int) = DedekindEtaPowers(len, 48)
"""
Compute the expansion of ``∏_{m≥1} (1 - q^m)^{64}``.
$(SIGNATURES)
"""
L010841(len::Int) = DedekindEtaPowers(len, 64)
"""
List of the first values of the Ramanujan tau function, the Fourier coefficients of the Weierstrass Delta-function.
$(SIGNATURES)
"""
RamanujanTauList(len::Int) = DedekindEtaPowers(len, 24)
"""
Return Ramanujan's tau(n).
$(SIGNATURES)
"""
RamanujanTau(n::Int) = DedekindEtaPowers(n, 24)[end]
"""
Return the first n numbers of integer partitions.
$(SIGNATURES)
"""
PartitionNumberList(len::Int) = DedekindEtaPowers(len, -1)
"""
Return the first n numbers of integer partitions.
$(SIGNATURES)
"""
L000041(len::Int) = DedekindEtaPowers(len, -1)
"""
Return the number of partitions of n into parts of 2 kinds.
$(SIGNATURES)
"""
L000712(len::Int) = DedekindEtaPowers(len, -2)
"""
Return the number of partitions of n into parts of 3 kinds.
$(SIGNATURES)
"""
L000716(len::Int) = DedekindEtaPowers(len, -3)
"""
Return the number of partitions of n into parts of 4 kinds.
$(SIGNATURES)
"""
L023003(len::Int) = DedekindEtaPowers(len, -4)
"""
Return the number of partitions of n into parts of 5 kinds.
$(SIGNATURES)
"""
L023004(len::Int) = DedekindEtaPowers(len, -5)
"""
Return the number of partitions of n into parts of 6 kinds.
$(SIGNATURES)
"""
L023005(len::Int) = DedekindEtaPowers(len, -6)
"""
Return the number of partitions of n into parts of 7 kinds.
$(SIGNATURES)
"""
L023006(len::Int) = DedekindEtaPowers(len, -7)
"""
Return the number of partitions of n into parts of 8 kinds.
$(SIGNATURES)
"""
L023007(len::Int) = DedekindEtaPowers(len, -8)
"""
Return the number of partitions of n into parts of 9 kinds.
$(SIGNATURES)
"""
L023008(len::Int) = DedekindEtaPowers(len, -9)
"""
Return the number of partitions of n into parts of 10 kinds.
$(SIGNATURES)
"""
L023009(len::Int) = DedekindEtaPowers(len, -10)
"""
Return the number of partitions of n into parts of 11 kinds.
$(SIGNATURES)
"""
L023010(len::Int) = DedekindEtaPowers(len, -11)
"""
Return the number of partitions of n into parts of 12 kinds.
$(SIGNATURES)
"""
L005758(len::Int) = DedekindEtaPowers(len, -12)
"""
Return the number of partitions of n into parts of 13 kinds.
$(SIGNATURES)
"""
L023011(len::Int) = DedekindEtaPowers(len, -13)
"""
Return the number of partitions of n into parts of 14 kinds.
$(SIGNATURES)
"""
L023012(len::Int) = DedekindEtaPowers(len, -14)
"""
Return the number of partitions of n into parts of 15 kinds.
$(SIGNATURES)
"""
L023013(len::Int) = DedekindEtaPowers(len, -15)
"""
Return the number of partitions of n into parts of 16 kinds.
$(SIGNATURES)
"""
L023014(len::Int) = DedekindEtaPowers(len, -16)
"""
Return the number of partitions of n into parts of 17 kinds.
$(SIGNATURES)
"""
L023015(len::Int) = DedekindEtaPowers(len, -17)
"""
Return the number of partitions of n into parts of 18 kinds.
$(SIGNATURES)
"""
L023016(len::Int) = DedekindEtaPowers(len, -18)
"""
Return the number of partitions of n into parts of 19 kinds.
$(SIGNATURES)
"""
L023017(len::Int) = DedekindEtaPowers(len, -19)
"""
Return the number of partitions of n into parts of 20 kinds.
$(SIGNATURES)
"""
L023018(len::Int) = DedekindEtaPowers(len, -20)
"""
Return the number of partitions of n into parts of 21 kinds.
$(SIGNATURES)
"""
L023019(len::Int) = DedekindEtaPowers(len, -21)
"""
Return the number of partitions of n into parts of 22 kinds.
$(SIGNATURES)
"""
L023020(len::Int) = DedekindEtaPowers(len, -22)
"""
Return the number of partitions of n into parts of 23 kinds.
$(SIGNATURES)
"""
L023021(len::Int) = DedekindEtaPowers(len, -23)
"""
Return the number of partitions of n into parts of 24 kinds.
$(SIGNATURES)
"""
L006922(len::Int) = DedekindEtaPowers(len, -24)
"""
Return the number of partitions of n into parts of 30 kinds.
$(SIGNATURES)
"""
L082556(len::Int) = DedekindEtaPowers(len, -30)
"""
Return the number of partitions of n into parts of 32 kinds.
$(SIGNATURES)
"""
L082557(len::Int) = DedekindEtaPowers(len, -32)
"""
Return the number of partitions of n into parts of 48 kinds.
$(SIGNATURES)
"""
L082558(len::Int) = DedekindEtaPowers(len, -48)
"""
Return the number of partitions of n into parts of 64 kinds.
$(SIGNATURES)
"""
L082559(len::Int) = DedekindEtaPowers(len, -64)
# *** Deleham.jl ****************
"""
Return the product of two integer sequences introduced by Philippe Deléham in A084938.
$(SIGNATURES)
"""
function DeléhamΔ(n::Int, S::Function, T::Function)
    n ≤ 0 && return fmpz[]
    R, x = PolynomialRing(ZZ, "x")
    A = [R(S(k) + x * T(k)) for k in 0:n - 2]
    C = [R(1) for i in 0:n]; C[1] = R(0)
    M = ZTriangle(n)
    m = 1
    for k in 0:n - 1
        for j in k + 1:-1:2
            C[j] = C[j - 1] + C[j + 1] * A[j - 1]
        end
        for j in 0:k
            M[m] = coeff(C[2], j)
            m += 1
        end
    end
    M
end
"""
Return the number of permutations of ``{1,2,...,n}`` having ``k`` cycles such that the elements of each cycle of the permutation form an interval. (Ran Pan)
$(SIGNATURES)
"""
T084938(n::Int) = DeléhamΔ(n, i -> div(i + 1, 2), i -> 0^i)
"""
Return the number of lattice paths from ``(0,0)`` to ``(x,y)`` that never pass below ``y = x`` and use step set ``{(0,1), (1,0), (2,0), (3,0), ...}``.
$(SIGNATURES)
"""
T011117(n::Int) = DeléhamΔ(n, i -> 0^i, i -> isodd(i) ? 1 : (i > 0 ? 2 : 0))
"""
Return the number of Schroeder paths (i.e., consisting of steps ``U=(1,1), D=(1,-1), H=(2,0)`` and never going below the x-axis) from ``(0,0)`` to ``(2n,0)``, having ``k`` peaks.
$(SIGNATURES)
"""
T060693(n::Int) = DeléhamΔ(n, i -> 1, i -> isodd(i) ? 0 : 1)
"""
Return the the Catalan convolution triangle.
$(SIGNATURES)
"""
T106566(n::Int) = DeléhamΔ(n, i -> i == 0 ? 0 : 1, i -> i == 0 ? 1 : 0)
"""
Return the number of increasing 0-2 trees (A002105) on ``2n`` edges in which the minimal path from the root has length ``k``.
$(SIGNATURES)
"""
T094665(n::Int) = DeléhamΔ(n, i -> div(i * (i + 1), 2), i -> i + 1)
"""
Return the number of lists of ``k`` unlabeled permutations whose total length is ``n``.
$(SIGNATURES)
"""
T090238(n::Int) = DeléhamΔ(n, i -> div(i, 2) + (isodd(i) ? 2 : 0), i -> i == 0 ? 1 : 0)
"""
Return the triangle ``4^k S_4(n, k)`` where ``S_m(n, k)`` are the Stirling-Frobenius cycle numbers of order ``m``.
$(SIGNATURES)
"""
T225478(n::Int) = DeléhamΔ(n, i -> 2(i + 1) + (i + 1) % 2, i -> isodd(i) ? 0 : 4)
"""
Return the exponential transform of Pascal's triangle.
$(SIGNATURES)
"""
T055883(n::Int) = DeléhamΔ(n, i -> isodd(i) ? div(i + 1, 2) : 1, i -> isodd(i) ? div(i + 1, 2) : 1)
"""
Return the number of Schroeder paths of length ``2n`` and having ``k`` ascents.
$(SIGNATURES)
"""
T090981(n::Int) = DeléhamΔ(n, i -> i == 0 ? 1 : (isodd(i) ? 0 : 2), i -> isodd(i) ? 1 : 0)
"""
Return a triangle related to the median Euler numbers.
$(SIGNATURES)
"""
T088969(n::Int) = DeléhamΔ(n, i -> i^2, i -> isodd(i) ? 3div(i, 2) + 2 : 5div(i, 2) + 1)
"""
Return the Bell transform of the Fubini numbers.
$(SIGNATURES)
"""
T184962(n::Int) = DeléhamΔ(n, i -> div((i + 1) - (i + 1) % 2, 2 - (i + 1) % 2), i -> isodd(i) ? 0 : 1)
# *** Fibonacci.jl ****************
struct FiboIterate
    length
end
function Base.iterate(I::FiboIterate)
    I.length == 0 && return nothing
    state = (ZZ(0), (ZZ(0), ZZ(1), ZZ(1)))
end
function Base.iterate(I::FiboIterate, (a, b, c))
    c >= I.length && return nothing
    (b, (b, a + b, c + 1))
end
Base.length(f::FiboIterate) = f.length
Base.eltype(f::FiboIterate) = Nemo.fmpz
"""
Iterate over the first ``n`` Fibonacci numbers.
$(SIGNATURES)
"""
I000045(n) = FiboIterate(n)
"""
Iterate over the Fibonacci numbers which do not exceed ``n``.
$(SIGNATURES)
"""
F000045(n) = IterTools.takewhile(k -> k <= n, FiboIterate(n+1))
"""
Return the first ``n`` Fibonacci numbers in an array.
$(SIGNATURES)
"""
L000045(n) = Base.collect(FiboIterate(n))
"""
Return the ``n``-th Fibonacci number.
$(SIGNATURES)
"""
function V000045(n)
   F = ZZ[1 1; 1 0]
   Fn = F^n
   Fn[2, 1]
end
"""
Return the ``n``-th Fibonacci number, explicite formula by Paul Hankin.
$(SIGNATURES)
"""
function HankinFibonacci(n)
    n < 2 && return n
    a = <<(ZZ(4), (n - 1) * (n + 2))
    b = <<(ZZ(4), 2 * (n - 1))
    c = <<(ZZ(2), n - 1)
    div(a, b - c - 1) & (c - 1)
end
"""
Fibonacci function for real values, returns a Float64.
$(SIGNATURES)
"""
function R000045(x::Float64)
    (Base.MathConstants.golden^x - cos(x * Base.MathConstants.pi) *
     Base.MathConstants.golden^(-x)) / sqrt(5)
end
"""
Query if ``n`` is a Fibonacci number, returns a Bool.
$(SIGNATURES)
"""
function is000045(n)
    d = 0
    for f in FiboIterate(n+2)
        d = n - f
        d <= 0 && break
    end
    d == 0
end
# *** FigurativeNumbers.jl ****************
"""
Return the polygonal number with shape k.
$(SIGNATURES)
"""
function PolygonalNumber(n, k)
    s = div(n^2 * (k - 2) - n * (k - 4), 2)
    k < 2 ? -s : s
end
"""
Return the pyramidal number with shape k.
$(SIGNATURES)
"""
function PyramidalNumber(n, k)
    s = div(3 * n^2 + n^3 * (k - 2) - n * (k - 5), 6)
    k < 2 ? -s : s
end
"""
Return the polygonal numbers of shape -2.
$(SIGNATURES)
"""
V014107(n) = PolygonalNumber(n, -2)
"""
Return the polygonal numbers of shape -1.
$(SIGNATURES)
"""
V095794(n) = PolygonalNumber(n, -1)
"""
Return the polygonal numbers of shape 0.
$(SIGNATURES)
"""
V067998(n) = PolygonalNumber(n, 0)
"""
Return the polygonal numbers of shape 1.
$(SIGNATURES)
"""
V080956(n) = PolygonalNumber(n, 1)
"""
Return the polygonal numbers of shape 2 (these are the natural numbers).
$(SIGNATURES)
"""
V001477(n) = PolygonalNumber(n, 2)
"""
Return the polygonal numbers of shape 3 (the triangular numbers).
$(SIGNATURES)
"""
V000217(n) = PolygonalNumber(n, 3)
"""
Return the polygonal numbers of shape 4 (the squares).
$(SIGNATURES)
"""
V000290(n) = PolygonalNumber(n, 4)
"""
Return the polygonal numbers of shape 5 (the pentagonal numbers).
$(SIGNATURES)
"""
V000326(n) = PolygonalNumber(n, 5)
"""
Return the polygonal numbers of shape 6 (the hexagonal numbers).
$(SIGNATURES)
"""
V000384(n) = PolygonalNumber(n, 6)
"""
Return the polygonal numbers of shape 7 (the heptagonal numbers).
$(SIGNATURES)
"""
V000566(n) = PolygonalNumber(n, 7)
"""
Return the polygonal numbers of shape 8 (the octagonal numbers).
$(SIGNATURES)
"""
V000567(n) = PolygonalNumber(n, 8)
"""
Return the polygonal numbers of shape 9 (the nonagonal numbers).
$(SIGNATURES)
"""
V001106(n) = PolygonalNumber(n, 9)
"""
Return the polygonal numbers of shape 10 (decagonal numbers).
$(SIGNATURES)
"""
V001107(n) = PolygonalNumber(n, 10)
"""
Return the pyramidal numbers of shape -1.
$(SIGNATURES)
"""
V005564(n) = PyramidalNumber(n, -1)
"""
Return the pyramidal numbers of shape 0.
$(SIGNATURES)
"""
V058373(n) = PyramidalNumber(n, 0)
"""
Return the pyramidal numbers of shape 1.
$(SIGNATURES)
"""
V254749(n) = PyramidalNumber(n, 1)
"""
Return the pyramidal numbers of shape 3 (tetrahedral numbers).
$(SIGNATURES)
"""
V000292(n) = PyramidalNumber(n, 3)
"""
Return the pyramidal numbers of shape 4 (square pyramidal numbers).
$(SIGNATURES)
"""
V000330(n) = PyramidalNumber(n, 4)
"""
Return the pyramidal numbers of shape 5 (pentagonal pyramidal numbers).
$(SIGNATURES)
"""
V002411(n) = PyramidalNumber(n, 5)
"""
Return the pyramidal numbers of shape 6 (hexagonal pyramidal numbers).
$(SIGNATURES)
"""
V002412(n) = PyramidalNumber(n, 6)
"""
Return the pyramidal numbers of shape 7 (heptagonal pyramidal numbers).
$(SIGNATURES)
"""
V002413(n) = PyramidalNumber(n, 7)
"""
Return the pyramidal numbers of shape 8 (octagonal pyramidal numbers).
$(SIGNATURES)
"""
V002414(n) = PyramidalNumber(n, 8)
"""
Return the pyramidal numbers of shape 9 (enneagonal pyramidal numbers).
$(SIGNATURES)
"""
V007584(n) = PyramidalNumber(n, 9)
"""
Return the pyramidal numbers of shape 10 (decagonal pyramidal numbers).
$(SIGNATURES)
"""
V007585(n) = PyramidalNumber(n, 10)
# *** GaussFactorialRecords.jl ****************
"""
Return ``∏_{1 ≤ j ≤ N, j ⊥ n} j``, the product of the positive integers which are ``≤ N`` and are prime to ``n``.
$(SIGNATURES)
"""
GaußFactorial(n) = prod([j for j in 1:Int(n) if ⊥(j, n)])
"""
Iterate over the indices of the first ``n`` record values of the Gauß factorial.
$(SIGNATURES)
"""
I193339(n) = Records(GaußFactorial, n, true, true)
"""
Iterate over indices of the record values of the Gauß factorial which do not exceed ``n`` (``1 ≤ i ≤ n``).
$(SIGNATURES)
"""
F193339(n) = Records(GaußFactorial, n, false, true)
"""
Return the indices of the first ``n`` record values of the Gauß factorial as an array.
$(SIGNATURES)
"""
L193339(n) = collect(I193339(n))
"""
Return the index of the ``n``-th record value of the Gauß factorial.
$(SIGNATURES)
"""
V193339(n) = nth(I193339(n), n)
"""
Iterate over the first ``n`` record values of the Gauß factorial (``1 ≤ r``).
$(SIGNATURES)
"""
I193338(n) = Records(GaußFactorial, n, true, false)
"""
Iterate over the record values of the Gauß factorial which do not exceed ``n`` (``1 ≤ i ≤ n``).
$(SIGNATURES)
"""
F193338(n) = Records(GaußFactorial, n, false, false)
"""
Return the first ``n`` record values of the Gauß factorial as an array.
$(SIGNATURES)
"""
L193338(n) = collect(I193338(n))
"""
Return the (value of the) ``n``-th record of the Gauß factorial.
$(SIGNATURES)
"""
V193338(n) = nth(I193338(n), n)
# *** GeneralizedBinomial.jl ****************
"""
The classical binomial coefficients defined for ``n≥0`` and ``0≤k≤n`` (a.k.a. Pascal's triangle).
$(SIGNATURES)
"""
function Pascal(n::Int, k::Int)
    (k == 0 || k == n) && return 1
    if k > div(n, 2) k = n - k end
    nk = n - k
    factors = fmpz[]
    rootN = isqrt(n)
    for prime in Primes(2, n)
        if prime > nk
            push!(factors, prime)
            continue
        end
        prime > div(n, 2) && continue
        if prime > rootN
            (n % prime < k % prime) && push!(factors, prime)
            continue
        end
        r, N, K, p = 0, n, k, 1
        while N > 0
            r = N % prime < (K % prime + r) ? 1 : 0
            if r == 1 p *= prime end
            N = div(N, prime)
            K = div(K, prime)
        end
        p > 1 && push!(factors, p)
    end
    ∏(factors) end
"""
Pascal's triangle.
$(SIGNATURES)
"""
function T007318(n::Int)
    T = zeros(QQ, div(n * (n + 1), 2))
    j = 1
    for m in 0:n - 1, k in 0:m
        T[j] = binom(m, k)
        j += 1
    end
    T
end
"""
Return the extended binomial coefficients defined for all ``n ∈ Z`` and ``k ∈ Z``. Behaves like the binomial function in Maple and Mathematica.
``\\binom{n}{k} = \\lim \\limits_{x \\rightarrow 1}(Γ(n + x) / (Γ(k + x) Γ(n - k + x))).``
$(SIGNATURES)
"""
function Binomial(n::Int, k::Int)
    0 ≤ k ≤ n  && return binom(n, k)
    k ≤ n <  0 && return binom(-k - 1, n - k) * (-1)^(n - k)
    n <  0 ≤ k && return binom(-n + k - 1, k) * (-1)^k
    ZZ(0)
end
# *** HighlyAbundant.jl ****************
"""
Iterate over the first ``n`` highly abundant numbers.
$(SIGNATURES)
"""
I002093(n) = Records(σ, n, true, true)
"""
Iterate over the highly abundant numbers which do not exceed ``n`` (``1 ≤ i ≤ n``).
$(SIGNATURES)
"""
F002093(n) = Records(σ, n, false, true)
"""
Return the first ``n`` highly abundant numbers as an array.
$(SIGNATURES)
"""
L002093(n) = collect(I002093(n))
"""
Return the ``n``-th highly abundant number.
$(SIGNATURES)
"""
V002093(n) = nth(I002093(n), n)
"""
Iterate over the first ``n`` record values of sigma.
$(SIGNATURES)
"""
I034885(n) = Records(σ, n, true, false)
"""
Iterate over the record values of sigma the indices of which do not exceed ``n`` (``1 ≤ r ≤ n``).
$(SIGNATURES)
"""
F034885(n) = Records(σ, n, false, false)
"""
Return the first ``n`` record values of sigma as an array.
$(SIGNATURES)
"""
L034885(n) = collect(I034885(n))
"""
Return the ``n``-th record of sigma.
$(SIGNATURES)
"""
V034885(n) = nth(I034885(n), n)
# *** Hyper1F1.jl ****************
"""
Return ``Γ(a) `` Hypergeometric``1F1(b, c, d).``
$(SIGNATURES)
"""
function GammaHyp(a, b, c, d)
    prec = 64
    while prec <= 10000
        CC = AcbField(prec)
        g = gamma(CC(a)) * hyp1f1(CC(b), CC(c), CC(d))
        b, i = unique_integer(g)
        b && return i
        prec = div(8*prec, 5)
    end
    error("GammaHyp with $a $b $c $d gives an InexactError!")
end
"""
Return ``(n+1)!`` Hypergeometric1F1``[-n, -n-1, -1]``. Number of fixedpoint-free permutations beginning with 2. (L. Euler).
$(SIGNATURES)
"""
V000255(n) = n == 0 ? ZZ(1) : GammaHyp(n + 2, -n, -n-1, -1)
"""
Return ``n!`` Hypergeometric1F1``[1-n, 2, -1]``. Number of partitions of ``{1,...,n}`` into any number of ordered subsets.
$(SIGNATURES)
"""
V000262(n) = n == 0 ? ZZ(1) : GammaHyp(n + 1, 1 - n, 2, -1)
"""
Return ``(n+1)!`` Hypergeometric1F1``[-n, -n-1, 1]``. Number of arrangements of ``{1, 2, ..., n+1}`` containing the element 1.
$(SIGNATURES)
"""
V001339(n) = n == 0 ? ZZ(1) : GammaHyp(n + 2, -n, -n-1, 1)
"""
Return ``(2n)!`` Hypergeometric1F1``[-n, -2n, -2]``. Number of ways ``n`` couples can sit in a row without any spouses next to each other.
$(SIGNATURES)
"""
V007060(n) = n == 0 ? ZZ(1) : GammaHyp(2n + 1, -n, -2n, -2)
"""
Return ``(2n)!`` Hypergeometric1F1``[-n, -2n, -1]``. Number of acyclic orientations of the Turán graph ``T(2n,n)``.
$(SIGNATURES)
"""
V033815(n) = n == 0 ? ZZ(1) : GammaHyp(2n + 1, -n, -2n, -1)
"""
Return ``(2n)!`` Hypergeometric1F1``[-n, -2n, 1]``.
$(SIGNATURES)
"""
V099022(n) = n == 0 ? ZZ(1) : GammaHyp(2n + 1, -n, -2n, 1)
"""
Return ``((2n)!/(n+1)!)`` Hypergeometric1F1``[1-n, n+2, -1]``. Egf. exp ``(x C(x)^2)`` where ``C(x) = 1 + xC(x)^2`` is the generating function of the Catalan numbers.
$(SIGNATURES)
"""
function V251568(n::Int)
    n == 0 && return fmpz(1)
    prec = 64
    while prec <= 10000
        CC = ComplexField(prec)
        c = gamma(CC(2 * n + 1)) * hyp1f1(CC(1 - n), CC(n + 2), CC(-1)) / gamma(CC(n + 2))
        b, i = unique_integer(c)
        b && return i
        prec *= 2
    end
    error("n = $n gives an InexactError!")
end
# *** JacobiTheta.jl ****************
"""
The ``q``-expansion to length len of the Jacobi theta function raised to the power ``r``, i.e. ``ϑ(q)^r`` where ``ϑ(q) = 1 + ∑_{k ≥ 1} q^{k^2}``. Number of ways of writing ``n`` as a sum of ``r`` squares.
$(SIGNATURES)
"""
function JacobiTheta3Powers(len::Int, r::Int)
    len ≤ 0 && return fmpz[]
    R, x = PolynomialRing(ZZ, "x")
    e = theta_qexp(r, len, x)
    [fmpz(coeff(e, j)) for j in 0:len - 1]
end
"""
Return the ``q``-expansion to length ``len`` of the Jacobi theta function raised to the power ``r``, i.e. ``ϑ(-q)^r`` where ``ϑ(q) = 1 + ∑_{k ≥ 1} q^{k^2} .``
$(SIGNATURES)
"""
function JacobiTheta4Powers(len::Int, r::Int)
    len ≤ 0 && return fmpz[]
    R, x = PolynomialRing(ZZ, "x")
    e = theta_qexp(r, len, -x)
    [fmpz(coeff(e, j)) for j in 0:len - 1]
end
"""
Return the number of ways of writing a nonnegative integer n as a square.
$(SIGNATURES)
"""
L000122(len::Int) = JacobiTheta3Powers(len, 1)
"""
Return the expansion of Jacobi theta function ``ϑ(-q)``.
$(SIGNATURES)
"""
L002448(len::Int) = JacobiTheta4Powers(len, 1)
"""
Return the number of ways of writing a nonnegative integer n as a sum of 2 squares.
$(SIGNATURES)
"""
L004018(len::Int) = JacobiTheta3Powers(len, 2)
"""
Return the expansion of ``ϑ_4(q)^2`` in powers of q.
$(SIGNATURES)
"""
L104794(len::Int) = JacobiTheta4Powers(len, 2)
"""
Return the number of ways of writing a nonnegative integer n as a sum of 3 squares.
$(SIGNATURES)
"""
L005875(len::Int) = JacobiTheta3Powers(len, 3)
"""
Return the expansion of ``ϑ_4(q)^3`` in powers of q.
$(SIGNATURES)
"""
L213384(len::Int) = JacobiTheta4Powers(len, 3)
"""
Number of ways of writing a nonnegative integer n as a sum
of 4 squares.
$(SIGNATURES)
"""
L000118(len::Int) = JacobiTheta3Powers(len, 4)
"""
Return the expansion of ``ϑ_4(q)^4`` in powers of q.
$(SIGNATURES)
"""
L096727(len::Int) = JacobiTheta4Powers(len, 4)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 5 squares.
$(SIGNATURES)
"""
L000132(len::Int) = JacobiTheta3Powers(len, 5)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 6 squares.
$(SIGNATURES)
"""
L000141(len::Int) = JacobiTheta3Powers(len, 6)
"""
Return the nnumber of ways of writing a nonnegative integer n as a sum
of 7 squares.
$(SIGNATURES)
"""
L008451(len::Int) = JacobiTheta3Powers(len, 7)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 8 squares.
$(SIGNATURES)
"""
L000143(len::Int) = JacobiTheta3Powers(len, 8)
"""
Return the expansion of ``ϑ_4(q)^8`` in powers of q.
$(SIGNATURES)
"""
L035016(len::Int) = JacobiTheta4Powers(len, 8)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 9 squares.
$(SIGNATURES)
"""
L008452(len::Int) = JacobiTheta3Powers(len, 9)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 10 squares.
$(SIGNATURES)
"""
L000144(len::Int) = JacobiTheta3Powers(len, 10)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 11 squares.
$(SIGNATURES)
"""
L008453(len::Int) = JacobiTheta3Powers(len, 11)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 12 squares.
$(SIGNATURES)
"""
L000145(len::Int) = JacobiTheta3Powers(len, 12)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 13 squares.
$(SIGNATURES)
"""
L276285(len::Int) = JacobiTheta3Powers(len, 13)
"""
Return the number of ways of writing a nonnegative integer n as a sum
of 14 squares.
$(SIGNATURES)
"""
L276286(len::Int) = JacobiTheta3Powers(len, 14)
"""
Return the nnumber of ways of writing a nonnegative integer n as a sum
of 15 squares.
$(SIGNATURES)
"""
L276287(len::Int) = JacobiTheta3Powers(len, 15)
"""
Return the expansion of ``1/ϑ_3(q)`` in powers of q.
$(SIGNATURES)
"""
L004402(len::Int) = JacobiTheta3Powers(len, -1)
"""
Return the expansion of ``1/ϑ_4(q)`` in powers of q.
$(SIGNATURES)
"""
L015128(len::Int) = JacobiTheta4Powers(len, -1)
"""
Return the expansion of ``1/ϑ_3(q)^2`` in powers of q.
$(SIGNATURES)
"""
L004403(len::Int) = JacobiTheta3Powers(len, -2)
"""
Return the expansion of ``1/ϑ_4(q)^2`` in powers of q.
$(SIGNATURES)
"""
L001934(len::Int) = JacobiTheta4Powers(len, -2)
"""
Return the expansion of ``1/ϑ_3(q)^3`` in powers of q.
$(SIGNATURES)
"""
L004404(len::Int) = JacobiTheta3Powers(len, -3)
"""
Return the expansion of ``1/ϑ_3(q)^4`` in powers of q.
$(SIGNATURES)
"""
L004405(len::Int) = JacobiTheta3Powers(len, -4)
"""
Return the expansion of ``1/ϑ_3(q)^5`` in powers of q.
$(SIGNATURES)
"""
L004406(len::Int) = JacobiTheta3Powers(len, -5)
"""
Return the expansion of ``1/ϑ_3(q)^6`` in powers of q.
$(SIGNATURES)
"""
L004407(len::Int) = JacobiTheta3Powers(len, -6)
"""
Return the expansion of ``1/ϑ_3(q)^7`` in powers of q.
$(SIGNATURES)
"""
L004408(len::Int) = JacobiTheta3Powers(len, -7)
"""
Return the expansion of ``1/ϑ_3(q)^8`` in powers of q.
$(SIGNATURES)
"""
L004409(len::Int) = JacobiTheta3Powers(len, -8)
"""
Return the expansion of ``1/ϑ_3(q)^9`` in powers of q.
$(SIGNATURES)
"""
L004410(len::Int) = JacobiTheta3Powers(len, -9)
"""
Return the expansion of ``1/ϑ_3(q)^{10}`` in powers of q.
$(SIGNATURES)
"""
L004411(len::Int) = JacobiTheta3Powers(len, -10)
"""
Return the expansion of ``1/ϑ_3(q)^{11}`` in powers of q.
$(SIGNATURES)
"""
L004412(len::Int) = JacobiTheta3Powers(len, -11)
"""
Return the expansion of ``1/ϑ_3(q)^{12}`` in powers of q.
$(SIGNATURES)
"""
L004413(len::Int) = JacobiTheta3Powers(len, -12)
"""
Return the expansion of ``1/ϑ_3(q)^{13}`` in powers of q.
$(SIGNATURES)
"""
L004414(len::Int) = JacobiTheta3Powers(len, -13)
"""
Return the expansion of ``1/ϑ_3(q)^{14}`` in powers of q.
$(SIGNATURES)
"""
L004415(len::Int) = JacobiTheta3Powers(len, -14)
"""
Return the expansion of ``1/ϑ_3(q)^{15}`` in powers of q.
$(SIGNATURES)
"""
L004416(len::Int) = JacobiTheta3Powers(len, -15)
"""
Return the expansion of ``1/ϑ_3(q)^{16}`` in powers of q.
$(SIGNATURES)
"""
L004417(len::Int) = JacobiTheta3Powers(len, -16)
"""
Return the expansion of ``1/ϑ_3(q)^{17}`` in powers of q.
$(SIGNATURES)
"""
L004418(len::Int) = JacobiTheta3Powers(len, -17)
"""
Return the expansion of ``1/ϑ_3(q)^{18}`` in powers of q.
$(SIGNATURES)
"""
L004419(len::Int) = JacobiTheta3Powers(len, -18)
"""
Return the expansion of ``1/ϑ_3(q)^{19}`` in powers of q.
$(SIGNATURES)
"""
L004420(len::Int) = JacobiTheta3Powers(len, -19)
"""
Return the expansion of ``1/ϑ_3(q)^{20}`` in powers of q.
$(SIGNATURES)
"""
L004421(len::Int) = JacobiTheta3Powers(len, -20)
"""
Return the expansion of ``1/ϑ_3(q)^{21}`` in powers of q.
$(SIGNATURES)
"""
L004422(len::Int) = JacobiTheta3Powers(len, -21)
"""
Return the expansion of ``1/ϑ_3(q)^{22}`` in powers of q.
$(SIGNATURES)
"""
L004423(len::Int) = JacobiTheta3Powers(len, -22)
"""
Return the expansion of ``1/ϑ_3(q)^{23}`` in powers of q.
$(SIGNATURES)
"""
L004424(len::Int) = JacobiTheta3Powers(len, -23)
"""
Return the expansion of ``1/ϑ_3(q)^{24}`` in powers of q.
$(SIGNATURES)
"""
L004425(len::Int) = JacobiTheta3Powers(len, -24)
# *** Kolakoski.jl ****************
"""
Generate the Kolakoski sequence which is the unique sequence over the alphabet ``{1, 2}`` starting with ``1`` and having the sequence of run lengths identical with itself.
$(SIGNATURES)
"""
C000002() = Channel(csize = 10) do c
    x = y = Int(-1)
    while true
        put!(c, [2, 1][(x & 1) + 1])
        f = y & ~(y + 1)
        x = xor(x, f)
        y = (y + 1) | (f & (x >> 1))
    end
end
struct KolakoskiSeq
    count::Int
    ch::Channel
    KolakoskiSeq(count) = new(count, C000002())
end
function Base.iterate(I::KolakoskiSeq)
    if I.count == 0
        close(I.ch)
        return nothing
    end
    (take!(I.ch), (0))
end
function Base.iterate(I::KolakoskiSeq, S)
    j = S[1] + 1
    if I.count == j
        close(I.ch)
        return nothing
    end
    (take!(I.ch), (j))
end
Base.length(I::KolakoskiSeq) = I.count
Base.eltype(I::KolakoskiSeq) = Int
"""
Iterate over the first ``n`` Kolakoski numbers.
$(SIGNATURES)
"""
I000002(n::Int) = KolakoskiSeq(n)
"""
Return the list of the first ``n`` terms of the Kolakoski sequence.
$(SIGNATURES)
"""
function KolakoskiList(len::Int)
    len ≤ 0 && return []
    generator = C000002()
    L = [take!(generator) for _ in 1:len]
    close(generator)
    return L
end
"""
Return the list of the first ``n`` terms of the Kolakoski sequence.
$(SIGNATURES)
"""
L000002(n::Int) = KolakoskiList(n)
# *** NarayanaCows.jl ****************
"""
The type object to construct a new instance of the modified Narayanas cows sequence with given length.
$(SIGNATURES)
"""
struct NarayanasCows
    length
end
"""
Return the first term of the modified Narayanas cows sequence.
$(SIGNATURES)
"""
function Base.iterate(I::NarayanasCows)
    I.length == 0 && return nothing
    state = (1, (0, 0, 1, 1))
end
"""
Return the next term of the modified Narayanas cows sequence.
$(SIGNATURES)
"""
function Base.iterate(I::NarayanasCows, (x, y, z, c))
    c >= I.length && return nothing
    x = div(z + x, gcd(z, x))
    (x, (y, z, x, c + 1))
end
Base.length(f::NarayanasCows) = f.length
Base.eltype(f::NarayanasCows) = Int
"""
Return a list of the first n terms of the modified Narayanas cows sequence.
$(SIGNATURES)
"""
L214551(n) = collect(NarayanasCows(n))
# *** NumberTheory.jl ****************
"""
Return true if n is prime false otherwise.
$(SIGNATURES)
"""
isPrime(n) = Nemo.isprime(fmpz(n))
"""
Return factors of ``n``.
$(SIGNATURES)
"""
Factors(n) = n == 0 ? [] : Nemo.factor(fmpz(n))
"""
Return the positive intgers dividing ``n``.
$(SIGNATURES)
"""
function Divisors(m, dosort=false)
    n = ZZ(m)
    n == ZZ(0) && return fmpz[]
    Nemo.isprime(n) && return [ZZ(1), n]
    d = [ZZ(1)]
    for (p, e) in Nemo.factor(n)
        d *= permutedims([p^i for i in 0:e])
        d = reshape(d, length(d))
    end
    dosort && sort!(d)
    d
end
"""
Return the prime numbers dividing ``n``.
$(SIGNATURES)
"""
function PrimeDivisors(n)
    n == 0 && return []
    isPrime(n) && return [fmpz(n)]
    f = Factors(n)
    sort!([p for (p, e) in f])
end
"""
Return the radical of ``n`` which is the product of the prime numbers dividing ``n`` (also called the squarefree kernel of ``n``).
$(SIGNATURES)
"""
Radical(n) = ∏(PrimeDivisors(n))
"""
Return ``Ω(n)``, the number of prime divisors of ``n`` counted with multiplicity (cf. A001222).
$(SIGNATURES)
"""
function Ω(n)
    n == fmpz(0) && return 0
    isPrime(n) && return fmpz(1)
    f = Factors(n)
    sum([e for (p, e) in f])
end
"""
Return the number of prime divisors of ``n`` counted with multiplicity.
$(SIGNATURES)
"""
V001222(n) = Ω(n)
"""
Return the result of replacing each prime factor of n with 2.
$(SIGNATURES)
"""
V061142(n) = 1 << Int(Ω(n))
"""
Return ``ω(n)``,  the number of distinct prime divisors of ``n`` (cf. A001221).
$(SIGNATURES)
"""
ω(n) = fmpz(length(PrimeDivisors(n)))
"""
Return the number of distinct prime divisors of ``n``.
$(SIGNATURES)
"""
V001221(n) = ω(n)
"""
Return the number of unitary divisors of ``n``, ``d`` such that ``d`` divides ``n`` and ``d ⊥ n/d``.
$(SIGNATURES)
"""
V034444(n::Int) = 1 << Int(ω(n))
"""
Return ``τ(n)`` (a.k.a. ``σ_0(n)``), the number of divisors of ``n`` (cf A000005).
$(SIGNATURES)
"""
τ(n) = Nemo.sigma(fmpz(n), 0)
"""
Return the number of divisors of ``n``.
$(SIGNATURES)
"""
V000005(n) = τ(n)
"""
Return ``σ(n)`` (a.k.a. ``σ_1(n)``), the sum of the divisors of ``n`` (cf. A000203).
$(SIGNATURES)
"""
σ(n) = Nemo.sigma(fmpz(n), 1)
"""
Return the Euler totient ``ϕ(n)``, numbers which are ``≤ n`` and prime to ``n``.
$(SIGNATURES)
"""
ϕ(n) = Nemo.eulerphi(fmpz(n))
"""
Return the number of integers ``≤ n`` and prime to ``n``.
$(SIGNATURES)
"""
V000010(n) = ϕ(n)
"""
Return the value of the Möbius function ``μ(n)`` which is the sum of the primitive n-th roots of unity.
$(SIGNATURES)
"""
μ(n) = Nemo.moebiusmu(fmpz(n))
"""
Return the value of the Möbius function ``μ(n)`` which is the sum of the primitive n-th roots of unity.
$(SIGNATURES)
"""
V008683(n) = μ(n)
"""
Return the sum of the divisors of ``n``.
$(SIGNATURES)
"""
V000203(n) = σ(n)
"""
Query if ``m`` is prime to ``n``.
$(SIGNATURES)
"""
isPrimeTo(m, n) = Nemo.gcd(fmpz(m), fmpz(n)) == fmpz(1)
"""
Query if ``m`` is prime to ``n``. Knuth, Graham and Patashnik write in "Concrete Mathematics": "Hear us, O mathematicians of the world! Let us not wait any longer! We can make many formulas clearer by defining a new notation now! Let us agree to write m ⊥ n, and to say "m is prime to n", if m and n are relatively prime."
$(SIGNATURES)
"""
⊥(m, n) = isPrimeTo(m, n)
"""
Query if ``m`` is strong prime to ``n``. ``m`` is strong prime to ``n`` iff ``m`` is prime to ``n`` and ``m`` does not divide ``n-1``.
$(SIGNATURES)
"""
isStrongPrimeTo(m, n) = isPrimeTo(m, n) && n ∉ Divisors(m - 1)
"""
Query if ``m`` is strong prime to ``n``. ``m`` is strong prime to ``n`` iff ``m`` is prime to ``n`` and ``m`` does not divide ``n-1``.
$(SIGNATURES)
"""
⍊(m, n) = isStrongPrimeTo(m, n)
function NumbersStronglyPrimeTo(n::Int)
    P = fmpz[m for m in 1:n if ⊥(m, n)]
    D = Divisors(n - 1)
    return setdiff(P, D)
end
"""
Return the number of integers ``≤ n`` which are strong prime to ``n``.
$(SIGNATURES)
"""
V181830(n) = n == 0 ? 0 : ϕ(n) - τ(n - 1)
"""
Is ``n`` a cyclic number? ``n`` such that there is just one group of order ``n``.
$(SIGNATURES)
"""
isCyclic(n) = n == 0 ? false : ⊥(n, ϕ(n))
"""
Iterate over the first ``n`` cyclic numbers.
$(SIGNATURES)
"""
I003277(n::Int) = Iterators.take(Iterators.filter(isCyclic, Iterators.countfrom(1)), n)
"""
Return the first ``n`` cyclic numbers in an array.
$(SIGNATURES)
"""
L003277(n::Int) = collect(I003277(n))
"""
Is ``n`` a strong cyclic number?
$(SIGNATURES)
"""
isStrongCyclic(n) = n == 0 ? false : ⍊(n, ϕ(n))
"""
Iterate over the first ``n`` strong cyclic numbers.
$(SIGNATURES)
"""
I050384(n::Int) = Iterators.take(Iterators.filter(isStrongCyclic, Iterators.countfrom(1)), n)
"""
Return the first ``n`` strong cyclic numbers in an array.
$(SIGNATURES)
"""
L050384(n::Int) = collect(I050384(n))
"""
Return the least absolute remainder. mods uses the symmetric representation for integers modulo m, i.e. remainders will be reduced to integers in the range ``[-``div``(|m| - 1, 2), ``div``(|m|, 2)]``.
$(SIGNATURES)
"""
function mods(b, a)
    b == 0 && return a
    h = a >> 1
    (q, r) = divrem(b, a)
    if h <  r  r -= a end
    if h < -r  r += a end
    r
end
"""
Is the integer ``n`` nonnegative?
$(SIGNATURES)
"""
isNonnegative(n) = n ≥ 0
"""
Is the integer ``n`` positive?
$(SIGNATURES)
"""
isPositive(n) = n > 0
"""
Is the integer ``n`` a square number?
$(SIGNATURES)
"""
isSquare(n) = Nemo.issquare(fmpz(n))
"""
Is the integer ``n`` a composite number?
$(SIGNATURES)
"""
isComposite(n) = (n > 0) && 1 < Ω(n)
"""
Is the integer ``n`` a squarefree number?
$(SIGNATURES)
"""
isSquareFree(n) = (n > 0) && ω(n) == Ω(n)
"""
Is the integer ``n`` a prime power?
$(SIGNATURES)
"""
isPrimePower(n) = ω(n) == 1
"""
Is the integer ``n`` a power of primes?
$(SIGNATURES)
"""
isPowerOfPrimes(n) = (n == 1) || (ω(n) == 1)
"""
Is the integer ``n`` a perfect powers?
$(SIGNATURES)
"""
isPerfectPower(n) = ω(n) == 1 && Ω(n) ≠ 1
"""
Return `true` if b is divisible by a, otherwise return `false`.
$(SIGNATURES)
"""
Divides(a, b) = a ≠ 0 && rem(fmpz(b), fmpz(a)) == fmpz(0)
"""
Is ``n`` divisble by 2?
$(SIGNATURES)
"""
isEven(n) = Base.iseven(n)
"""
Is ``n`` indivisble by 2?
$(SIGNATURES)
"""
isOdd(n) = Base.isodd(n)
"""
Return the primorial of ``n``, the product of the primes ``≤ n``.
$(SIGNATURES)
"""
V034386(n) = Nemo.primorial(n)
"""
Return a list of the first ``n`` primes.
$(SIGNATURES)
"""
PrimeList(len::Int) = Iterators.take(Iterators.filter(isPrime, Iterators.countfrom(1)), len)
"""
Return the product of first ``n`` primes.
$(SIGNATURES)
"""
V002110(n) = ∏(PrimeList(n))
# *** OEISUtils.jl ****************
srcdir = realpath(joinpath(dirname(@__FILE__)))
ROOTDIR = dirname(srcdir)
datadir = joinpath(ROOTDIR, "data")
"""
Returns the path where the oeis data is expected.
$(SIGNATURES)
"""
oeis_path() = joinpath(datadir, "stripped")
"""
Indicates if the local copy of the OEIS data (the so-called 'stripped' file) is installed (in ../data).
$(SIGNATURES)
"""
oeis_isinstalled() = isfile(oeis_path())
"""
Indicates if the local copy of the OEIS data (the so-called 'stripped' file) is not installed and warns.
$(SIGNATURES)
"""
function oeis_notinstalled()
    if !oeis_isinstalled()
        @warn("OEIS data not installed! Download stripped.gz from oeis.org,")
        @warn("expand it and put it in the directory ../data.")
        return true
    end
    return false
end
"""
Write a so-called b-file for submission to the OEIS. The file is saved in the 'data' directory.
$(SIGNATURES)
"""
function oeis_writebfile(anum::String, fun::Function, range::OrdinalRange)
    if !occursin(r"^A[0-9]{6}$", anum)
        @warn("Not a valid A-number!")
        return
    end
    filename = joinpath(datadir, "b" * anum[2:end] * ".txt")
    @info("Writing " * anum * " to " * filename)
    f = open(filename, "w")
    for n in range
        println(f, n, " ", fun(n))
    end
    close(f)
end
function oeis_writebfile(anum, list, offset=1)
    if !occursin(r"^A[0-9]{6}$", anum)
        @warn("Not a valid A-number!")
        return
    end
    filename = joinpath(datadir, "b" * anum[2:end] * ".txt")
    @info("Writing " * anum * " to " * filename)
    n = offset
    f = open(filename, "w")
    for l in list
        println(f, n, " ", list[n])
        n += 1
    end
    close(f)
end
"""
Read a file in the so-called b-file format of the OEIS.
$(SIGNATURES)
"""
function oeis_readbfile(filename)
    @info("Reading "  * filename)
    file = open(filename, "r")
    lines = readlines(file)
    for l in lines
        s = split(l, ' ')
        i = parse(Int, s[1])
        v = parse(Int, s[2])
        println(i, " ", v)
    end
    close(file)
end
"""
Make sure that the length of the data section of an OEIS entry does not exceed 260 characters.
$(SIGNATURES)
"""
function oeis_trimdata(fun, offset::Int)
    len = n = 0
    S = ""
    while true
        st = string(fun(offset + n))
        len += length(st)
        len > 260 && break
        S *= st * ", "
        len += 2
        n += 1
    end
    println(n, " terms")
    return S
end
"""
Download the sequence with A-number 'anum' from the OEIS to a file in json format. The file is saved in the 'data' directory.
$(SIGNATURES)
"""
function oeis_remote(anum)
    if !occursin(r"^A[0-9]{6}$", anum)
        @warn("Not a valid A-number!")
        return
    end
    filename = joinpath(datadir, anum * ".json")
    url = HTTP.URI("http://oeis.org/search?q=id:" * anum * "&fmt=json")
    tries = 3
    r = nothing
    for i = 1:tries
        try
            r = HTTP.get(url; readtimeout=2)
            getfield(r, :status) == 200 && break
            getfield(r, :status) == 302 && break
        catch e
            @warn(e)
        end
        sleep(2)
    end
    if r ≠ nothing && getfield(r, :status) == 200
        open(filename, "w") do f
            write(f, getfield(r, :body))
        end
        @info("Dowloaded " * basename(filename) * " to " * datadir)
    else
        if r === nothing
            @warn("Could not download $url, connection timed out.\n")
        else
            @warn("Could not download $url\nStatus: $(getfield(r, :status))")
        end
    end
end
"""
Get the sequence with A-number 'anum' from a local copy of the expanded 'stripped.gz' file which can be downloaded from the OEIS. 'bound' is an upper bound for the number of terms returned. The 'stripped' file is assumed to be in the '../data' directory.
$(SIGNATURES)
"""
function oeis_local(anum::String, bound::Int)
    if !occursin(r"^A[0-9]{6}$", anum)
        @warn(anum * " is not a valid A-number!")
        return []
    end
    oeis_notinstalled() && return []
    A = Array{String}
    data = open(oeis_path())
    for ln in eachline(data)
        if startswith(ln, anum)
            A = split(chop(chomp(ln)), ","; limit=bound + 2)
            break;
        end
    end
    close(data)
    [convert(fmpz, parse(BigInt, n)) for n in A[2:min(bound + 1, end)]]
end
"""
Search for a sequence in the local OEIS database ('../data/stripped'). Input the sequence as a comma separated string. If restart = true the search is redone in the case that no match was found with the first term removed from the search string. Prints the matches.
$(SIGNATURES)
"""
function oeis_search(seq::String, restart::Bool)
    oeis_notinstalled() && return []
    found = false
    seq = replace(seq, ' ' => "")
    println("Searching for:")
    println(seq)
    data = open(oeis_path())
    for line in eachline(data)
        index = findfirst(seq, line)
        index === nothing && continue
        println("Range ", index , " in line: ", line)
        found = true
    end
    close(data)
    if !found && restart
        ind = findfirst(isequal(','), seq)
        if !(ind === nothing) && (length(seq) > ind)
            seq = seq[ind + 1:end]
            println("Restarting omitting the first term.")
            oeis_search(seq, false)
        end
    end
end
# *** OrthoPolynomials.jl ****************
"""
By the theorem of Favard an orthogonal polynomial systems  ``p_{n}(x)`` is a sequence of real polynomials with deg``(p_{n}(x)) = n`` for all ``n`` if and only if
`` p_{n+1}(x) = (x - s_n)p_n(x) - t_n p_{n-1}(x) ``
with ``p_{0}(x)=1`` for some pair of seq's ``s_k`` and ``t_k``. Return the coefficients of the polynomials as a triangular array with `dim` rows.
$(SIGNATURES)
"""
function OrthoPoly(dim::Int, s::Function, t::Function)
    dim ≤ 0 && return fmpz[]
    T = zeros(ZZ, dim, dim)
    for n in 1:dim T[n, n] = 1 end
    for n in 2:dim
        for k in 1:n-1
            T[n, k] = ((k > 1 ? T[n-1, k - 1] : 0)
                    + s(k-1) * T[n-1, k]
                    + t(k ) * T[n-1, k + 1])
        end
    end
    [T[n,k] for n in 1:dim for k in 1:n]
end
"""
Return the inverse of the coefficients of the orthogonal polynomials generated by ``s`` and ``t`` as a triangular array with `dim` rows.
$(SIGNATURES)
"""
function InvOrthoPoly(dim::Int, s::Function, t::Function)
    dim ≤ 0 && return fmpz[]
    T = zeros(ZZ, dim, dim)
    for n in 1:dim T[n, n] = 1 end
    for n in 1:dim - 1
        for k in 1:n + 1
            T[n+1, k] = ((k > 1 ? T[n, k - 1] : 0)
                      - s(n - 1) * T[n, k]
                      - (n > 1 ? t(n - 1) * T[n - 1, k] : 0))
        end
    end
    [T[n,k] for n in 1:dim for k in 1:n]
end
"""
Return the Catalan triangle (with 0's) read by rows.
$(SIGNATURES)
"""
T053121(dim::Int) = OrthoPoly(dim, n -> 0, n -> 1)
"""
Return the coefficients of some orthogonal polynomials related to set partitions without singletons (cf. A000296).
$(SIGNATURES)
"""
T216916(dim::Int) = OrthoPoly(dim, n -> n + 1, n -> n + 1)
"""
Return the triangle ``T(n,k)`` of tangent numbers, coefficient of ``x^n/n!`` in the expansion of ``(\\tan x)^k/k!``.
$(SIGNATURES)
"""
T059419(dim::Int) = OrthoPoly(dim, n -> 0, n -> n * (n-1))
"""
Return the expansion of ``\\exp(\\tan(x))``.
$(SIGNATURES)
"""
L006229(len::Int) = RowSums(T059419(len))
"""
Return the first len integers defined as ``a(n) = n! [x^n] \\exp(2 \\exp (x) - x - 2)``.
$(SIGNATURES)
"""
L217924(len::Int) = RowSums(T217537(len))
"""
Return the coefficients of some orthogonal polynomials related to indecomposable set partitions without singletons (cf. A098742).
$(SIGNATURES)
"""
T217537(dim::Int) = OrthoPoly(dim, n -> n , n -> n )
"""
Return the (reflected) Motzkin triangle.
$(SIGNATURES)
"""
T064189(dim::Int) = OrthoPoly(dim, n -> 1, n -> 1)
"""
Return the number of directed animals of size n as an array of length len.
$(SIGNATURES)
"""
L005773(len::Int) = RowSums(T064189(len))
"""
Return the coefficients of ``x^n`` in the expansion of ``((-1-x+√(1+2x+5x^2))/2)^k`` as a triangle with dim rows.
$(SIGNATURES)
"""
T202327(dim::Int) = OrthoPoly(dim, n -> -1, n -> -1)
"""
Return the sequence with generating function satisfying ``x = (A(x)+(A(x))^2)/(1-A(x)-(A(x))^2)``.
$(SIGNATURES)
"""
L108624(len::Int) = RowSums(T202327(len))
"""
Return the triangle ``T(n, k) = \\binom{n}{k} \\times`` involutions``(n - k)``.
$(SIGNATURES)
"""
T111062(dim::Int) = OrthoPoly(dim, n -> 1, n -> n)
"""
Return the number of self-inverse partial permutations.
$(SIGNATURES)
"""
L005425(len::Int) = RowSums(T111062(len))
"""
Return the coefficients of the modified Hermite polynomials.
$(SIGNATURES)
"""
T099174(dim::Int) = OrthoPoly(dim, n -> 0, n -> n)
"""
Return the number of involutions.
$(SIGNATURES)
"""
L000085(len::Int) = RowSums(T099174(len))
"""
Return the coefficients of unitary Hermite polynomials He``_n(x)``.
$(SIGNATURES)
"""
T066325(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> n)
"""
Return the sequence defined by ``a(n) = n! [x^n] \\exp(-x-(x^2)/2)``.
$(SIGNATURES)
"""
L001464(len::Int) = RowSums(T066325(len), true)
"""
Return the triangle of tanh numbers.
$(SIGNATURES)
"""
T111593(dim::Int) = OrthoPoly(dim, n -> 0, n -> -n * (n - 1))
"""
Return the sequence defined by ``A(n) = n! [x^n] \\exp \\tan(x)`` as an array of length `len`.
$(SIGNATURES)
"""
L003723(len::Int) = RowSums(T111593(len))
"""
Return the coefficients of Chebyshev's U``(n, x/2)`` polynomials.
$(SIGNATURES)
"""
T049310(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> 1)
"""
Return the coefficients of the Charlier polynomials with parameter ``a = 1``.
$(SIGNATURES)
"""
T137338(dim::Int) = InvOrthoPoly(dim, n -> n + 1, n -> n + 1)
"""
Return the inverse of the Motzkin triangle (cf. A064189).
$(SIGNATURES)
"""
T104562(dim::Int) = InvOrthoPoly(dim, n -> 1, n -> 1)
"""
Return the skew Fibonacci-Pascal triangle with `dim` rows.
$(SIGNATURES)
"""
T037027(dim::Int) = InvOrthoPoly(dim, n -> -1, n -> -1)
"""
Return the arctangent numbers (expansion of arctan``(x)^n/n!``).
$(SIGNATURES)
"""
T049218(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> n * (n + 1))
"""
Return the coefficients of Hermite polynomials ``H(n, (x-1)/√(2))/(√(2))^n``.
$(SIGNATURES)
"""
T159834(dim::Int) = InvOrthoPoly(dim, n -> 1, n -> n)
"""
Return the coefficients of a variant of the Hermite polynomials.
$(SIGNATURES)
"""
T137286(dim::Int) = InvOrthoPoly(dim, n -> 0, n -> n + 1)
"""
Return the coefficients of the Chebyshev-T polynomials.
$(SIGNATURES)
"""
function T053120(len)
    T = ZTriangle(len)
    R, x = PolynomialRing(ZZ, "x")
    m = 1
    for n in 0:len - 1
        f = chebyshev_t(n, x)
        for k in 0:n
            T[m] = coeff(f, k)
            m += 1
        end
    end
    T
end
"""
Return the coefficients of the Chebyshev-U polynomials.
$(SIGNATURES)
"""
function T053117(len)
    T = ZTriangle(len)
    R, x = PolynomialRing(ZZ, "x")
    m = 1
    for n in 0:len - 1
        f = chebyshev_u(n, x)
        for k in 0:n
            T[m] = coeff(f, k)
            m += 1
        end
    end
    T
end
# *** Partitions.jl ****************
"""
Generates the integer partitions of ``n`` in lexicographic order. Ported from Wilf/Nijenhuis "Combinatorial Algorithms". (cf. A080577).
$(SIGNATURES)
"""
function NEXPAR(N::Int)
    PAR = Array{Int}(undef, N)
    R = Dict{Int,Int}()
    M = Dict{Int,Int}()
    NLAST = 0
    D = 0
@label(L10)
    N == NLAST && @goto(L20)
    NLAST = N
@label(L30)
    S = N
    D = 0
@label(L50)
    D = D + 1
    R[D] = S
    M[D] = 1
@label(L40)
    MTC = M[D] ≠ N
    fill!(PAR, 0)
    K = 0
    for I in 1:D, J in 1:M[I]
        K = K + 1
        PAR[K] = R[I]
    end
    VISIT(PAR)
    ! MTC && return
    @goto(L10)
@label(L20)
    ! MTC && @goto(L30)
    SUM = 1
    R[D] > 1 && @goto(L60)
    SUM = M[D] + 1
    D = D - 1
@label(L60)
    F = R[D] - 1
    M[D] == 1 && @goto(L70)
    M[D] = M[D] - 1
    D = D + 1
@label(L70)
    R[D] = F
    M[D] = 1 + div(SUM, F)
    S = SUM % F
    S == 0 && @goto(L40)
    @goto(L50)
end
"""
Prints the partitions given in the format used in function NEXPAR.
$(SIGNATURES)
"""
function VISIT(P)
    println(P)
end
"""
Generates the integer partitions of ``n`` in graded reverse lexicographic order, the canonical ordering of partitions.
$(SIGNATURES)
"""
Partition(n) = NEXPAR(n)
"""
Generates the integer partitions of ``n`` in graded reverse lexicographic order, the canonical ordering of partitions.
$(SIGNATURES)
"""
V080577(n) = NEXPAR(n)
# *** PrimesIterator.jl ****************
const wheel         = [4,  2,  4,  2,  4,  6,  2,  6]
const wheel_primes  = [7, 11, 13, 17, 19, 23, 29, 31]
const wheel_indices = [0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,3,4,4,5,5,5,5,6,6,6,6,6,6,7,7]
@inline function wheel_index(n)
    d, r = divrem(n - 1, 30)
    return 8d + wheel_indices[r + 2]
end
@inline function wheel_prime(n)
    d, r = (n - 1) >>> 3, (n - 1) & 7
    return 30d + wheel_primes[r + 1]
end
function mask(limit::Int)
    limit < 7 && throw(ArgumentError("The condition limit ≥ 7 must be met."))
    n = wheel_index(limit)
    m = wheel_prime(n)
    sieve = ones(Bool, n)
    @inbounds for i = 1:wheel_index(isqrt(limit))
        if sieve[i]
            p = wheel_prime(i)
            q = p^2
            j = (i - 1) & 7 + 1
            while q ≤ m
                sieve[wheel_index(q)] = false
                q += wheel[j] * p
                j = j & 7 + 1
            end
        end
    end
    return sieve
end
function mask(lo::Int, hi::Int)
    7 ≤ lo ≤ hi || throw(ArgumentError("The condition 7 ≤ lo ≤ hi must be met."))
    lo == 7 && return mask(hi)
    wlo, whi = wheel_index(lo - 1), wheel_index(hi)
    m = wheel_prime(whi)
    sieve = ones(Bool, whi - wlo)
    hi < 49 && return sieve
    small_sieve = mask(isqrt(hi))
    @inbounds for i = 1:length(small_sieve)  # don't use eachindex here
        if small_sieve[i]
            p = wheel_prime(i)
            j = wheel_index(2 * div(lo - p - 1, 2p) + 1)
            q = p * wheel_prime(j + 1)
            j = j & 7 + 1
            while q ≤ m
                sieve[wheel_index(q) - wlo] = false
                q += wheel[j] * p
                j = j & 7 + 1
            end
        end
    end
    return sieve
end
"""
Return the prime sieve, as a `BitArray`, of the positive integers (from `lo`, if specified) up to `hi`. Useful when working with either primes or composite numbers.
$(SIGNATURES)
"""
function PrimeSieve(lo::Int, hi::Int)
    0 < lo ≤ hi || throw(ArgumentError("The condition 0 < lo ≤ hi must be met."))
    sieve = falses(hi - lo + 1)
    lo ≤ 2 ≤ hi && (sieve[3 - lo] = true)
    lo ≤ 3 ≤ hi && (sieve[4 - lo] = true)
    lo ≤ 5 ≤ hi && (sieve[6 - lo] = true)
    hi < 7 && return sieve
    wheel_sieve = mask(max(7, lo), hi)
    lsi = lo - 1
    lwi = wheel_index(lsi)
    @inbounds for i = 1:length(wheel_sieve)   # don't use eachindex here
        sieve[wheel_prime(i + lwi) - lsi] = wheel_sieve[i]
    end
    return sieve
end
function PrimeSieve(lo::T, hi::T) where {T <: Integer}
    lo ≤ hi ≤ typemax(Int) && return PrimeSieve(Int(lo), Int(hi))
    throw(ArgumentError("Both endpoints of the interval to sieve must be ≤ $(typemax(Int)), got $lo and $hi."))
end
PrimeSieve(limit::Int) = PrimeSieve(1, limit)
function PrimeSieve(n::Integer)
    n ≤ typemax(Int) && return PrimeSieve(Int(n))
    throw(ArgumentError("Requested number of primes must be ≤ $(typemax(Int)), got $n."))
end
"""
Return the collection of the prime numbers (from `lo`, if specified) up to `hi`.
$(SIGNATURES)
"""
function Primes(lo::Int, hi::Int)
    lo ≤ hi || throw(ArgumentError("The condition lo ≤ hi must be met."))
    list = Int[]
    lo ≤ 2 ≤ hi && push!(list, 2)
    lo ≤ 3 ≤ hi && push!(list, 3)
    lo ≤ 5 ≤ hi && push!(list, 5)
    hi < 7 && return list
    lo = max(2, lo)
    sizehint!(list, 5 + floor(Int, hi / (log(hi) - 1.12) - lo / (log(lo) - 1.12 * (lo > 7))))
    sieve = mask(max(7, lo), hi)
    lwi = wheel_index(lo - 1)
    @inbounds for i = 1:length(sieve)
        sieve[i] && push!(list, wheel_prime(i + lwi))
    end
    return list
end
Primes(n::Int) = Primes(1, n)
"""
Return the number of primes ``≤ n``.
$(SIGNATURES)
"""
PrimePi(n::Int) = length(Primes(1, n))
# *** PrimeSwingFactorial.jl ****************
const SwingOddpart = [1,1,1,3,3,15,5,35,35, 315, 63, 693, 231,
   3003, 429, 6435, 6435, 109395,12155,230945,46189,969969,
   88179,2028117, 676039,16900975,1300075,35102025,5014575,
   145422675,9694845,300540195,300540195]
"""
Computes the odd part of the swinging factorial ``n≀`` (cf. A163590).
$(SIGNATURES)
"""
function swing_oddpart(n::Int)
    n < 33 && return ZZ(SwingOddpart[n+1])
    sqrtn = isqrt(n)
    factors = Primes(div(n,2) + 1, n)
    P = Primes(sqrtn + 1, div(n, 3))
    s = [p for p in P if isodd(div(n, p))]
    for prime in Primes(3, sqrtn)
        p, q = 1, n
        while true
            q = div(q, prime)
            q == 0 && break
            isodd(q) && (p *= prime)
        end
        p > 1 && push!(s, p)
    end
    return ∏(factors)*∏(s)
end
"""
Computes the swinging factorial (a.k.a. Swing numbers n≀) (cf. A056040).
$(SIGNATURES)
"""
function Swing(n::Int)
    sh = count_ones(div(n, 2))
    swing_oddpart(n) << sh
end
const FactorialOddPart = [1, 1, 1, 3, 3, 15, 45, 315, 315, 2835, 14175, 155925,
    467775, 6081075, 42567525, 638512875, 638512875, 10854718875, 97692469875,
    1856156927625, 9280784638125, 194896477400625, 2143861251406875,
    49308808782358125, 147926426347074375, 3698160658676859375]
"""
Return the largest odd divisor of ``n!``. Cf. A049606.
$(SIGNATURES)
"""
function factorial_oddpart(n::Int)
    n < length(FactorialOddPart) && return ZZ(FactorialOddPart[n+1])
    swing_oddpart(n)*(factorial_oddpart(div(n,2))^2)
end
"""
Return the factorial ``n! = 1×2× ... ×n``, which is the order of the symmetric group S_n or the number of permutations of n letters (cf. A000142).
$(SIGNATURES)
"""
function PSfactorial(n::Int)
    n < 0 && ArgumentError("Argument must be >= 0")
    sh = n - count_ones(n)
    factorial_oddpart(n) << sh
end
# *** Products.jl ****************
"""
If ``a ≤ b`` then return the product of ``i`` in ``a:b`` else return ``1``.
$(SIGNATURES)
"""
function ∏(a, b)
    n = b - a
    if n < 24
        p = ZZ(1)
        for k in a:b
            p *= k
        end
        return ZZ(p)
    end
    m = div(a + b, 2)
    ∏(a, m) * ∏(m + 1, b)
end
"""
If ``a ≤ b`` then return the product of ``i`` in ``a:b`` else return ``1``.
$(SIGNATURES)
"""
Product(a, b) = ∏(a, b)
"""
Return the accumulated product of an array.
$(SIGNATURES)
"""
function ∏(A)
    function prod(a, b)
        n = b - a
        if n < 24
            p = ZZ(1)
            for k in a:b
                p *= A[k]
            end
            return ZZ(p)
        end
        m = div(a + b, 2)
        prod(a, m) * prod(m + 1, b)
    end
    A == [] && return 1
    prod(1, length(A))
end
"""
Return the accumulated product of an array.
$(SIGNATURES)
"""
Product(A) = ∏(A)
"""
Return frac``{n!} {⌊n/2⌋!}``.
$(SIGNATURES)
"""
V081125(n::Int) = ∏(div(n, 2) + 1, n)
"""
Return the rising factorial which is the product of ``i`` in ``n:(n + k - 1)``.
$(SIGNATURES)
"""
RisingFactorial(n::Int, k::Int) = ∏(n, n + k - 1)
"""
Return the rising factorial which is the product of ``i`` in ``n:(n + k - 1)``. A convenient infix syntax for the rising factorial is n ↑ k.
$(SIGNATURES)
"""
↑(n, k) = RisingFactorial(n, k)
"""
Return the rising factorial i.e. the product of ``i`` in ``n:(n + k - 1)``.
$(SIGNATURES)
"""
V265609(n::Int, k::Int) = RisingFactorial(n, k)
"""
Return the falling factorial which is the product of ``i`` in ``(n - k + 1):n``.
$(SIGNATURES)
"""
FallingFactorial(n::Int, k::Int) = ∏(n - k + 1, n)
"""
Return the falling factorial which is the product of ``i`` in ``(n - k + 1):n``. A convenient infix syntax for the falling factorial is n ↓ k.
$(SIGNATURES)
"""
↓(n, k) = FallingFactorial(n, k)
"""
Return the number of permutations of n letters, ``n! = ∏(1, n)``, the factorial of ``n``. (The notation is a shortcut breaking Julia conventions.)
$(SIGNATURES)
"""
F!(n::Int) = Nemo.fac(n)
"""
Return the factorial numbers.
$(SIGNATURES)
"""
V000142(n::Int) = Nemo.fac(n)
"""
Return the central rising factorial ``(n+1) ↑ (n+1) = (2n+1)! / n!``.
$(SIGNATURES)
"""
V000407(n::Int) = (n + 1) ↑ (n + 1)
"""
Return the restricted rising factorial which is zero for ``n < 0`` or ``k > n``.
$(SIGNATURES)
"""
V124320(n::Int, k::Int) = (n < 0 || k > n) ? 0 : ∏(n, n + k - 1)
"""
Return the multi-factorial which is the function ``n → ∏(a + b, a(n-1) + b)``
$(SIGNATURES)
"""
MultiFactorial(a::Int, b::Int) = n -> ∏([a * k + b for k in 0:(n - 1)])
"""
Return the double factorial of odd numbers, ``1×3×5×...×(2n-1) = (2n-1)!!``.
$(SIGNATURES)
"""
V001147(n::Int) = MultiFactorial(2, 1)(n)
"""
Return the double factorial of even numbers: ``2^n n! = (2n)!!``.
$(SIGNATURES)
"""
V000165(n::Int) = MultiFactorial(2, 2)(n)
"""
Return the triple factorial numbers with shift 1, ``3^n n! = (3n)!!!``.
$(SIGNATURES)
"""
V007559(n::Int) = MultiFactorial(3, 1)(n)
"""
Return the triple factorial numbers with shift 2.
$(SIGNATURES)
"""
V008544(n::Int) = MultiFactorial(3, 2)(n)
"""
Return the triple factorial numbers with shift 3.
$(SIGNATURES)
"""
V032031(n::Int) = MultiFactorial(3, 3)(n)
"""
Return the quadruple factorial numbers with shift 1.
$(SIGNATURES)
"""
V007696(n::Int) = MultiFactorial(4, 1)(n)
"""
Return the quadruple factorial numbers with shift 2, ``(2n)!/n!``.
$(SIGNATURES)
"""
V001813(n::Int) = MultiFactorial(4, 2)(n) # = ∏(n + 1, 2n)
"""
Return the quadruple factorial numbers with shift 3.
$(SIGNATURES)
"""
V008545(n::Int) = MultiFactorial(4, 3)(n)
"""
Return the quadruple factorial numbers ``4^n n!``.
$(SIGNATURES)
"""
V047053(n::Int) = MultiFactorial(4, 4)(n)
# *** QueensProblems.jl ****************
function solve!(profile, level, size, start, cols, diag4, diag1)
    if level > 0
        for i in start:size
            save = cols & (1 << i) +
            diag1 & (1 << (i + level)) +
            diag4 & (1 << (32 + i - level))
            if save == 0
                cols  = xor(cols,  1 << i)
                diag1 = xor(diag1, 1 << (i + level))
                diag4 = xor(diag4, 1 << (32 + i - level))
                solve!(profile, level - 1, size, 0, cols, diag4, diag1)
                cols  = xor(cols,  1 << i)
                diag1 = xor(diag1, 1 << (i + level))
                diag4 = xor(diag4, 1 << (32 + i - level))
                profile[level + 1] += 1
            end
        end
    else
        for i in 0:size
            save = cols & (1<<i) + diag1 & (1<<i) + diag4 & (1<<(32+i))
            save == 0 && (profile[1] += 1)
        end
    end
end
function search(n::Int)
    profile = zeros(Int, n + 1)
    cols = diag4 = diag1 = Int(0)
    solve!(profile, n - 1, n - 1, 0, cols, diag4, diag1)
    return profile
end
"""
Returns the profile of the backtrack tree for the n queens problem (see `[A319284]`).
$(SIGNATURES)
"""
function Queens(n::Int)
    n == 0 && return [1]
    profile = search(n)
    profile[n+1] = 1  # add the root
    [profile[n-i+1] for i = 0:n]
end
"""
Returns the profile of the backtrack tree for the n queens problem.
$(SIGNATURES)
"""
L319284(n) = Queens(n)
# *** RecordSearch.jl ****************
"""
The type object to construct an iterated search for records in sequences.
$(SIGNATURES)
"""
struct Records
    "function representing the sequence"
    fun::Function
    "search limit OR search length"
    lim::Int
    "true ↦ search all below lim, false ↦ search length items"
    below::Bool
    "true ↦ return index of record, false ↦ return value of record"
    index::Bool
end
Base.iterate(::Records) = (ZZ(0), (ZZ(0), ZZ(0), ZZ(1)))
"""
Return the value or the index of the next record.
$(SIGNATURES)
"""
function Base.iterate(R::Records, state)
    h, n, s = state
    (R.below ? s : n) >= R.lim && return nothing
    while true
        v = R.fun(n)
        v > h && return (R.index ? n : v, (v, n + 1, s + 1))
        n += 1
    end
end
Base.length(R::Records) = R.lim
Base.eltype(R::Records) = fmpz
# *** RiordanSquares.jl ****************
"""
Return the Riordan array associated with the generating functions a and b.
$(SIGNATURES)
"""
function RiordanProduct(a, b, dim, expo=false)
    A = Coefficients(a, dim)
    B = b == nothing ? A : Coefficients(b, dim)
    M = identity_matrix(QQ, dim)
    for k in 1:dim M[k, 1] = A[k] end
    for k in 2:dim, m in k+1:dim
        M[m, k] = sum(M[j+1, k-1]*B[m-j] for j in k-2:m-2)
    end
    toΔ(M)
end
"""
Return the Riordan array (Riordan product) ``a \times a``.
$(SIGNATURES)
"""
RiordanSquare(a, n, expo=false) = RiordanProduct(a, nothing, n, expo)
"""
The Riordan square of the Catalan numbers.
$(SIGNATURES)
"""
T039599(n) = RiordanSquare(G000108, n)
"""
The Riordan square of the central trinomial.
$(SIGNATURES)
"""
T116392(n) = RiordanSquare(G002426, n)
"""
The Riordan square of the little Schröder numbers.
$(SIGNATURES)
"""
T172094(n) = RiordanSquare(G001003, n)
"""
The Riordan square of the Riordan numbers (with 1 prepended).
$(SIGNATURES)
"""
T321620(n) = RiordanSquare(G005043, n)
"""
The Riordan square of the Motzkin numbers.
$(SIGNATURES)
"""
T321621(n) = RiordanSquare(G001006, n)
"""
The Riordan square of the large Schröder numbers.
$(SIGNATURES)
"""
T321623(n) = RiordanSquare(G006318, n)
"""
The Riordan square of the Lucas numbers.
$(SIGNATURES)
"""
T321624(n) = RiordanSquare(G000032, n)
"""
The Riordan square of the Jacobsthal numbers.
$(SIGNATURES)
"""
T322942(n) = RiordanSquare(G001045, n)
"""
The Riordan square of the number of rooted bicubic maps.
$(SIGNATURES)
"""
Txxx(n) = RiordanSquare(G000257, n)
# *** SelfConvolutive.jl ****************
Convolution(A, n) = sum(A[j+1] * A[n-j+1] for j in 0:n)
"""
An exactly solvable self-convolutive recurrence studied by R. J. Martin and M. J. Kearney.
$(SIGNATURES)
"""
function SelfConvRec(len, a, b, c)
    A = fill(ZZ(0), len)
    len == 0 && return A
    A[1] = 1
    for n in 1:len - 1
        A[n+1] = (a * (n + 1) + b) * A[n] + c * Convolution(A, n-1)
    end
    A
end
"""
Return the number of indecomposable perfect matchings on ``[2n]``.
$(SIGNATURES)
"""
L000698(len::Int) = SelfConvRec(len, 2, -3, 1)
"""
Return the order of alternating group ``A_n``, or number of even permutations of ``n`` letters.
$(SIGNATURES)
"""
L001710(len::Int) = SelfConvRec(len, 1, 1, 0)
"""
Return the number of connected permutations of ``[1..n]``. Also called indecomposable permutations.
$(SIGNATURES)
"""
L003319(len::Int) = SelfConvRec(len, 1, -2, 1)
"""
Return the number of non-vanishing Feynman diagrams of order ``2n`` for the electron or the photon propagators in quantum electrodynamics.
$(SIGNATURES)
"""
L005411(len::Int) = SelfConvRec(len, 2, -4, 1)
"""
Return the number of non-vanishing Feynman diagrams of order ``2n`` for the vacuum polarization in quantum electrodynamics.
$(SIGNATURES)
"""
L005412(len::Int) = SelfConvRec(len, 2, -2, 1)
"""
Counting some sets of permutations.
$(SIGNATURES)
"""
L006012(len::Int) = SelfConvRec(len, -1, 2, 2)
"""
Return the large Schröder numbers.
$(SIGNATURES)
"""
L006318(len::Int) = SelfConvRec(len, 0, 1, 1)
"""
Return the number of planar rooted trees with ``n`` nodes and tricolored end nodes.
$(SIGNATURES)
"""
L047891(len::Int) = SelfConvRec(len, 0, 2, 1)
"""
Return the number of rooted unlabeled connected triangular maps on a compact closed oriented surface with ``2n`` faces.
$(SIGNATURES)
"""
L062980(len::Int) = SelfConvRec(len, 6, -8, 1)
"""
Return the number of lattice paths from ``(0,0)`` to ``(n+1,n+1)`` that consist of steps ``(i,0)`` and ``(0,j)`` with ``i,j≥1`` and stay strictly below the diagonal line ``y=x`` except at the endpoints.
$(SIGNATURES)
"""
L082298(len::Int) = SelfConvRec(len, 0, 3, 1)
"""
Return the number of Schröder paths of semilength n in which the (2,0)-steps come in 4 colors.
$(SIGNATURES)
"""
L082301(len::Int) = SelfConvRec(len, 0, 4, 1)
"""
Return the coefficients in the expansion of ``(1-5x-√(25x^2-14x+1))/(2x)``.
$(SIGNATURES)
"""
L082302(len::Int) = SelfConvRec(len, 0, 5, 1)
"""
Return the coefficients in the expansion of ``(1+2x-√(1+4x^2))/(2x)``.
$(SIGNATURES)
"""
L105523(len::Int) = SelfConvRec(len, 0, -2, 1)
"""
A transform the of triple factorial numbers.
$(SIGNATURES)
"""
L107716(len::Int) = SelfConvRec(len, 3, -4, 1)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111529(len::Int) = SelfConvRec(len, 1, -3, 2)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111530(len::Int) = SelfConvRec(len, 1, -4, 3)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111531(len::Int) = SelfConvRec(len, 1, -5, 4)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111532(len::Int) = SelfConvRec(len, 1, -6, 5)
"""
A convolutory inverse of the factorial sequence.
$(SIGNATURES)
"""
L111533(len::Int) = SelfConvRec(len, 1, -7, 6)
"""
Return the expansion of ``(1-x)/(1 - 2x + 2x^2)``.
$(SIGNATURES)
"""
L146559(len::Int) = SelfConvRec(len, 1, 1, -2)
"""
Return half the number of Feynman diagrams of order ``2(n+1)``, for the electron self-energy in quantum electrodynamics.
$(SIGNATURES)
"""
L167872(len::Int) = SelfConvRec(len, 2, -3, 2)
# *** SeqUtils.jl ****************
"""
Think of a 'Nemo.fmpz' as a 'BigInt'. 'fmpz' stands for 'fast multiple precision zahl (Zahl=integer)'. Nemo is a library designed, developed and maintained by William Hart with the help of others. The mathematical symbol for the ring of
integers is the blackbord (double-struck) Z, also written ZZ. In reference to this ZZ(n) defines the integer n as a fmpz.
$(SIGNATURES)
"""
function Nemofmpz(n::Int) return ZZ(n) end
"""
Return an array of type `fmpz` of length ``n`` preset with ``0``.
$(SIGNATURES)
"""
ZArray(len::Int) = zeros(ZZ, len)
"""
Return an array of type fmpz and of size ``n`` filled by the values of the function ``f`` in the range `offset:n`.
$(SIGNATURES)
"""
function ZArray(n::Int, f::Function, offset=1)
    n ≤ 0 && return fmpz[]
    fmpz[f(k) for k in offset:offset+n-1] # !
end
"""
Return the size of the array ``A``.
$(SIGNATURES)
"""
SeqSize(A) = Base.length(A)
"""
Return the range of a SeqArray.
$(SIGNATURES)
"""
SeqRange(A) = 1:SeqSize(A)
"""
Print the array ``A`` in the format ``n ↦ A[n]`` for n in the given range.
$(SIGNATURES)
"""
function SeqShow(A::Array, R::AbstractRange, offset=0)
    for k in R
        if isassigned(A, k)
            println(k + offset, " ↦ ", A[k])
        else
            println(k + offset, " ↦ ", "undef")
        end
    end
end
"""
Print the array ``A`` in the format ``n ↦ A[n]`` for n in the range first:last.
$(SIGNATURES)
"""
SeqShow(A, first::Int, last::Int) = SeqShow(A, first:last)
"""
Print the array ``A`` in the format ``n ↦ A[n]``.
$(SIGNATURES)
"""
SeqShow(A::Array, offset=0) = SeqShow(A, 1:length(A), offset - 1)
function print_without_type(io, v::AbstractVector)
    print(io, "[")
    for (i, el) in enumerate(v)
        i > 1 && print(io, ", ")
        print(io, el)
    end
    println(io, "]")
end
"""
Print the array without typeinfo.
$(SIGNATURES)
"""
Println(v::AbstractVector) = print_without_type(IOContext(stdout), v)
"""
Print the array with or without typeinfo.
$(SIGNATURES)
"""
function SeqPrint(v::AbstractVector, typeinfo = false)
    typeinfo ? println(v) : Println(v)
end
"""
Return the name of a OEIS sequence given a similar named function as a string.
$(SIGNATURES)
"""
function SeqName(fun)
    aname = string(fun)
    for X in ['L', 'F', 'T', 'G', 'B', 'Q', 'V']
        aname = replace(aname, X => 'A')
    end
    if !occursin(r"^A[0-9]{6}$", aname)
        fullname = split(aname, ".")
        aname = String(fullname[end])
        if !occursin(r"^A[0-9]{6}$", aname)
            @error(aname, " is not a valid A-name!")
            return
        end
    end
    aname
end
"""
Return the A-number of a OEIS sequence given a similar named function as an integer.
$(SIGNATURES)
"""
function SeqNum(seq)
    aname = SeqName(seq)
    parse(Int, aname[2:end])
end
# *** SeriesExpansion.jl ****************
"""
Return the list of coefficients of the power series s.
$(SIGNATURES)
"""
function Coefficients(s, len)
    R, x = PowerSeriesRing(ZZ, len + 2, "x")
    ser = s(x)
    [coeff(ser, k) for k in 0:len-1]
end
"""
The generating function of the Lucas numbers.
$(SIGNATURES)
"""
G000032(x) = 1 + divexact(x*(1 + 2x), 1 - x - x^2)
"""
Return a list of Lucas numbers.
$(SIGNATURES)
"""
L000032(n) = Coefficients(G000032, n)
"""
The generating function of the Fibonacci numbers.
$(SIGNATURES)
"""
G000045(x) = divexact(x, 1 - x - x^2)
"""
The generating function of the Tribonacci numbers.
$(SIGNATURES)
"""
G000073(x) = inv(1 - x - x^2 - x^3)
"""
Return a list of Tribonacci numbers.
$(SIGNATURES)
"""
L000073(n) = Coefficients(G000073, n)
"""
The generating function of the Catalan numbers.
$(SIGNATURES)
"""
G000108(x) = divexact(1 - sqrt(1 - 4x), 2x)
"""
Return a list of Catalan numbers.
$(SIGNATURES)
"""
L000108(n) = Coefficients(G000108, n)
"""
The generating function of the number of rooted bicubic maps.
$(SIGNATURES)
"""
G000257(x) = divexact(sqrt((1 - 8x)^3) + 8x^2 + 12x - 1, 32x^2)
"""
Return a list of the number of rooted bicubic maps.
$(SIGNATURES)
"""
L000257(n) = Coefficients(G000257, n)
"""
The generating function of the Fine numbers (with a(0) = 1).
$(SIGNATURES)
"""
G000957(x) = 1 + divexact(1 - sqrt(1 - 4x), 3 - sqrt(1 - 4x))
"""
Return a list of Fine numbers.
$(SIGNATURES)
"""
L000957(n) = Coefficients(G000957, n)
"""
The generating function of the little Schröder numbers.
$(SIGNATURES)
"""
G001003(x) = divexact(1 + x - sqrt(1 - 6x + x^2), 4x)
"""
Return a list of little Schröder numbers.
$(SIGNATURES)
"""
L001003(n) = Coefficients(G001003, n)
"""
The generating function of the Motzkin numbers.
$(SIGNATURES)
"""
G001006(x) = divexact(1 - x - sqrt(1 - 2x - 3x^2), 2x^2)
"""
Return a list of Motzkin numbers.
$(SIGNATURES)
"""
L001006(n) = Coefficients(G001006, n)
"""
The generating function of the Jacobsthal numbers (with a(0) = 1).
$(SIGNATURES)
"""
G001045(x) = divexact(2x^2 - 1, (x + 1)*(2x - 1))
"""
Return a list of Jacobsthal numbers.
$(SIGNATURES)
"""
L001045(n) = Coefficients(G001045, n)
"""
The generating function of the central trinomial.
$(SIGNATURES)
"""
G002426(x) = inv(sqrt(1 - 2x - 3x^2))
"""
Return a list of the central trinomials.
$(SIGNATURES)
"""
L002426(n) = Coefficients(G002426, n)
"""
The generating function of the Riordan numbers with 1 prepended.
$(SIGNATURES)
"""
G005043(x) = 1 + divexact(2x , 1 + x + sqrt(1 - 2x - 3x^2))
"""
Return a list of the Riordan numbers (1 prepended).
$(SIGNATURES)
"""
L005043(n) = Coefficients(G005043, n)
"""
The generating function of the large Schröder numbers.
$(SIGNATURES)
"""
G006318(x) = divexact(1 - x - sqrt(1 - 6x + x^2), 2x)
"""
The generating function of twice the Catalan numbers.
$(SIGNATURES)
"""
G068875(x) = shift_right(1 - x - sqrt(1 - 4x), 1)
"""
Return a list of twice the Catalan numbers.
$(SIGNATURES)
"""
L068875(n) = Coefficients(G068875, n)
# *** StirlingLahNumbers.jl ****************
"""
Recurrence for A132393, StirlingCycle numbers.
$(SIGNATURES)
"""
function R132393(n::Int, k::Int, prevrow::Function)
    (k == 0 && n == 0) && return ZZ(1)
    (n - 1)*prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A048993, StirlingSet numbers.
$(SIGNATURES)
"""
function R048993(n::Int, k::Int, prevrow::Function)
    (k == 0 && n == 0) && return ZZ(1)
    k*prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A271703, Lah numbers.
$(SIGNATURES)
"""
function R271703(n::Int, k::Int, prevrow::Function)
    (k == 0 && n == 0) && return ZZ(1)
    (k - 1 + n)*prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A094587.
$(SIGNATURES)
"""
function R094587(n::Int, k::Int, prevrow::Function)
    (k == 0 && n == 0) && return ZZ(1)
    (n - k)*prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A008279. Number of permutations of n things k at a time.
$(SIGNATURES)
"""
function R008279(n::Int, k::Int, prevrow::Function)
    (k == 0 && n == 0) && return ZZ(1)
    prevrow(k) + k*prevrow(k - 1)
end
"""
Iterates over the first n rows of `A132393`.
$(SIGNATURES)
"""
I132393(n) = RecTriangle(n, R132393)
"""
Iterates over the first n rows of `A048993`.
$(SIGNATURES)
"""
I048993(n) = RecTriangle(n, R048993)
"""
Iterates over the first n rows of `A271703`.
$(SIGNATURES)
"""
I271703(n) = RecTriangle(n, R271703)
"""
Iterates over the first n rows of `A094587`.
$(SIGNATURES)
"""
I094587(n) = RecTriangle(n, R094587)
"""
Iterates over the first n rows of `A008279`.
$(SIGNATURES)
"""
I008279(n) = RecTriangle(n, R008279)
"""
Lists the first n rows of `A132393` by concatenating.
$(SIGNATURES)
"""
L132393(n) = vcat(I132393(n)...)
"""
Lists the first n rows of `A048993` by concatenating.
$(SIGNATURES)
"""
L048993(n) = vcat(I048993(n)...)
"""
Lists the first n rows of `A271703` by concatenating.
$(SIGNATURES)
"""
L271703(n) = vcat(I271703(n)...)
"""
Lists the first n rows of `A094587` by concatenating.
$(SIGNATURES)
"""
L094587(n) = vcat(I094587(n)...)
"""
Lists the first n rows of `A008279` by concatenating.
$(SIGNATURES)
"""
L008279(n) = vcat(I008279(n)...)
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M132393(dim) = fromΔ(I132393(dim))
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M048993(dim) = fromΔ(I048993(dim))
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M271703(dim) = fromΔ(I271703(dim))
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M094587(dim) = fromΔ(I094587(dim))
"""
Return the triangular array as a square matrix with dim rows.
$(SIGNATURES)
"""
M008279(dim) = fromΔ(I008279(dim))
"""
Return row n of A132393 based on the iteration `I132393`(n).
$(SIGNATURES)
"""
V132393(n) = nth(I132393(n+1), n+1)
"""
Return row n of A048993 based on the iteration `I048993`(n).
$(SIGNATURES)
"""
V048993(n) = nth(I048993(n+1), n+1)
"""
Return row n of A271703 based on the iteration `I271703`(n).
$(SIGNATURES)
"""
V271703(n) = nth(I271703(n+1), n+1)
"""
Return row n of A094587 based on the iteration `I094587`(n).
$(SIGNATURES)
"""
V094587(n) = nth(I094587(n+1), n+1)
"""
Return row n of A008279 based on the iteration `I008279`(n).
$(SIGNATURES)
"""
V008279(n) = nth(I008279(n+1), n+1)
# *** SwingFactorial.jl ****************
"""
Return the factorial of ``n``. Basic implementation of the swing algorithm using no primes. An advanced version based on prime-factorization is available as the prime-swing factorial factorialPS.
$(SIGNATURES)
"""
function Sfactorial(n::Int)::fmpz
    smallOddFactorial =           fmpz[0x0000000000000000000000000000001,
    0x0000000000000000000000000000001, 0x0000000000000000000000000000001,
    0x0000000000000000000000000000003, 0x0000000000000000000000000000003,
    0x000000000000000000000000000000f, 0x000000000000000000000000000002d,
    0x000000000000000000000000000013b, 0x000000000000000000000000000013b,
    0x0000000000000000000000000000b13, 0x000000000000000000000000000375f,
    0x0000000000000000000000000026115, 0x000000000000000000000000007233f,
    0x00000000000000000000000005cca33, 0x0000000000000000000000002898765,
    0x00000000000000000000000260eeeeb, 0x00000000000000000000000260eeeeb,
    0x0000000000000000000000286fddd9b, 0x00000000000000000000016beecca73,
    0x000000000000000000001b02b930689, 0x00000000000000000000870d9df20ad,
    0x0000000000000000000b141df4dae31, 0x00000000000000000079dd498567c1b,
    0x00000000000000000af2e19afc5266d, 0x000000000000000020d8a4d0f4f7347,
    0x000000000000000335281867ec241ef, 0x0000000000000029b3093d46fdd5923,
    0x0000000000000465e1f9767cc5866b1, 0x0000000000001ec92dd23d6966aced7,
    0x0000000000037cca30d0f4f0a196e5b, 0x0000000000344fd8dc3e5a1977d7755,
    0x000000000655ab42ab8ce915831734b, 0x000000000655ab42ab8ce915831734b,
    0x00000000d10b13981d2a0bc5e5fdcab, 0x0000000de1bc4d19efcac82445da75b,
    0x000001e5dcbe8a8bc8b95cf58cde171, 0x00001114c2b2deea0e8444a1f3cecf9,
    0x0002780023da37d4191deb683ce3ffd, 0x002ee802a93224bddd3878bc84ebfc7,
    0x07255867c6a398ecb39a64b83ff3751, 0x23baba06e131fc9f8203f7993fc1495]
    function oddProduct(m::Int, len::Int)
        if len < 24
            p = fmpz(m)
            for k in 2:2:2(len-1)
                p *= (m - k)
            end
            return p
        end
        hlen = len >> 1
        oddProduct(m - 2 * hlen, len - hlen) * oddProduct(m, hlen)
    end
    function oddFactorial(n)
        if n < 41
            oddFact = smallOddFactorial[1+n]
            sqrOddFact = smallOddFactorial[1+div(n, 2)]
        else
            sqrOddFact, oldOddFact = oddFactorial(div(n, 2))
            len = div(n - 1, 4)
            (n % 4) != 2 && (len += 1)
            high = n - ((n + 1) & 1)
            oddSwing = div(oddProduct(high, len), oldOddFact)
            oddFact = sqrOddFact^2 * oddSwing
        end
        (oddFact, sqrOddFact)
    end
    n < 0 && ArgumentError("n must be ≥ 0")
    if n == 0 return fmpz(1) end
    sh = n - count_ones(n)
    oddFactorial(n)[1] << sh
end
# *** Triangles.jl ****************
abstract type AbstractTriangle end
"""
A Triangle is a list of rows. The rows of the triangle are generated by a function `(n::Int, k::Int) → gen::fmpz` for ``0 ≤ k ≤ n`` and ``0 ≤ n <``dim.
$(SIGNATURES)
"""
struct Triangle <: AbstractTriangle
    dim::Int
    gen::Function
    function Triangle(dim::Int, gen::Function)
        dim <= 0 && throw(ArgumentError("dim has to be a positive integer."))
        new(dim, (n::Int, k::Int) -> gen(n, k)::fmpz )
    end
end
"""
Return the first row of the triangle.
$(SIGNATURES)
"""
function Base.iterate(T::Triangle)
    ([T.gen(0, 0)], 1)
end
"""
Return the next row of the triangle.
$(SIGNATURES)
"""
function Base.iterate(T::Triangle, n)
    n >= T.dim && return nothing
    row = [T.gen(n, k) for k in 0:n]
    (row, n + 1)
end
Base.length(T::Triangle) = T.dim
Base.eltype(T::Triangle) = fmpz
"""
A recursive triangle `RecTriangle` is a subtype of `AbstractTriangle`.
The rows of the triangle are generated by a function `gen(n, k, prevrow)` defined for ``n ≥ 0`` and ``0 ≤ k ≤ n``. The function returns value of type Nemo.fmpz.
The parameter prevrow is a function which returns the values of `row(n-1)` of the triangle and 0 if ``k < 0`` or ``k > n``. The function prevrow is provided
by an instance of `RecTriangle` and must not be defined by the user.
$(SIGNATURES)
"""
struct RecTriangle <: AbstractTriangle
    dim::Int
    A::Array{fmpz}
    gen::Function  # generating function
    function RecTriangle(dim::Int, gen::Function)
        dim <= 0 && throw(ArgumentError("dim has to be a positive integer."))
        new( dim,
             fill(ZZ(0), dim),
             (n::Int, k::Int, f::Function) -> gen(n, k, f)::fmpz)
    end
end
function Base.iterate(T::RecTriangle)
    top = T.gen(0, 0, () -> undefined)
    T.A[1] = ZZ(top)
    ([top], 1)
end
"""
Return the next row of the triangle.
$(SIGNATURES)
"""
function Base.iterate(T::RecTriangle, n)
    @inline prevrow(A, n) = (k) -> (k<0 || k>n) ? ZZ(0) : A[k+1]
    n == T.dim && return nothing
    F(n, k) = T.gen(n, k, prevrow(T.A, n))
    row = [F(n, k) for k in 0:n]
    for k in 1:n+1 T.A[k] = row[k] end
    (row, n + 1)
end
Base.length(R::RecTriangle) = R.dim
Base.eltype(R::RecTriangle) = fmpz
"""
Return the``n``-th triangular number.
$(SIGNATURES)
"""
TriangularNumber(n) = div(n * (n + 1), 2)
"""
Is ``n`` a triangular number?
$(SIGNATURES)
"""
isTriangular(n) = n == TriangularNumber(isqrt(2n))
"""
Return the square root of ``2n`` or throw an ArgumentError if ``n`` is not a triangular number.
$(SIGNATURES)
"""
function assertTriangular(n)
    dim = isqrt(2n)
    n ≠ TriangularNumber(dim) && throw(ArgumentError("This is not a triangular array!"))
    return dim
end
"""
Return a trianguler array with ``n`` rows set to ``0`` (type ZZ).
$(SIGNATURES)
"""
ZTriangle(dim::Int) = zeros(ZZ, TriangularNumber(dim))
"""
Return a trianguler array with ``n`` rows set to ``0`` (type QQ).
$(SIGNATURES)
"""
QTriangle(dim::Int) = zeros(QQ, TriangularNumber(dim))
"""
Return the triangle as a list of rows.
$(SIGNATURES)
"""
TriangularArray(T::AbstractTriangle) = [row for row in T]
"""
Return the triangle as a list of integers.
$(SIGNATURES)
"""
TriangleToList(T::AbstractTriangle) = [k for row in T for k in row]
"""
Return row ``n (0 ≤ n)`` of the lower triangular matrix T or the row ``n`` in reversed order if `reversed` is set true.
$(SIGNATURES)
"""
function Row(T, n, reversed=false)
    s = length(T)
    (s == 0 || n < 0) && return []
    assertTriangular(s)
    t = TriangularNumber(n+1)
    s < t && error("This row is not in the matrix.")
    R = reversed ? range(t, step=-1, stop=t-n) : range(t-n, step=1, stop=t)
    return [T[k] for k in R]
end
"""
Return the row sums of a triangle, if `alternate=true` then the alternating row sums.
$(SIGNATURES)
"""
function RowSums(T, alternate = false)
    n = length(T)
    n == 0 && return T
    len = assertTriangular(n)
    S = zeros(ZZ, len)
    lo = hi = 0
    step = 0
    while hi < n
        if alternate
            s = sum((-1)^k * T[lo+k+1] for k in 0:hi - lo)
        else
            s = sum(T[k+1] for k in lo:hi)
        end
        step += 1
        S[step] = s
        hi += 1
        lo, hi = hi, hi + step
    end
    S
end
"""
Display a lower triangular matrix.
$(SIGNATURES)
"""
function ShowAsΔ(T::AbstractTriangle, separator=", ")
    for row in T
        for k in row print(k, separator) end
        println()
    end
end
"""
Display an array as a lower triangular matrix.
$(SIGNATURES)
"""
function ShowAsΔ(T::AbstractArray, separator=", ")
    if typeof(T) == Array{Array{fmpz,1},1}
        for row in T
            for k in row print(k, separator) end
            println()
        end
    elseif typeof(T) == Array{fmpz,2}
        for row in 1:size(T,1)
            T[row,:]' |> Println
        end
    elseif typeof(T) == Array{fmpz,1}
        dim = assertTriangular(length(T))
        low = high = 1
        for r in 2:dim+1
            [T[j] for j = low:high] |> Println
            low, high = high + 1, high + r
        end
    else
        println(T)
    end
end
"""
Convert a lower triangular array to a square matrix.
$(SIGNATURES)
"""
function fromΔ(T::AbstractTriangle)
    L = TriangleToList(T)
    dim = assertTriangular(length(L))
    A = fill(ZZ(0), dim, dim)
    k = 1
    for r in 1:dim
        for j = 1:r
            A[r, j] = L[k]
            k += 1
        end
    end
    A
end
"""
Convert a square matrix to a list using only the ``T(n,k)`` with ``0 ≤ k ≤ n``. Returns a ZArray.
$(SIGNATURES)
"""
function toΔ(M)
    dim = size(M, 1)
    T = ZTriangle(dim)
    k = 1
    if typeof(M[1, 1]) == Nemo.fmpq
        for r in 1:dim, j = 1:r
            T[k] = numerator(M[r, j])
            k += 1
        end
    else
        for r in 1:dim, j = 1:r
            T[k] = M[r, j]
            k += 1
        end
    end
    T
end
"""
Print the triangle in matrix form.
$(SIGNATURES)
"""
ShowAsMatrix(T) = println(fromΔ(T))
# *** UlamNumbers.jl ****************
"""
Is ``n`` an Ulam number?
$(SIGNATURES)
"""
function isUlam(u, n, h, i, r)
    ur = u[r]; ui = u[i]
    ur <= ui && return h
    if ur + ui > n
        r -= 1
    elseif ur + ui < n
        i += 1
    else
        h && return false
        h = true; i += 1; r -= 1
    end
    isUlam(u, n, h, i, r)
end
"""
Return a list of Ulam numbers u(n), u(n) the least number > u(n-1) which is
a unique sum of two distinct earlier terms, u(1) = 1 and u(2) = 2.
$(SIGNATURES)
"""
function UlamList(len)
    u = Array{Int, 1}(undef, len)
    u[1] = 1; u[2] = 2
    i = 2; n = 2
    while i < len
        n += 1
        if isUlam(u, n, false, 1, i)
            i += 1
            u[i] = n
        end
    end
    return u
end
"""
Return a list of Ulam numbers.
$(SIGNATURES)
"""
L002858(len) = UlamList(len)
# *** ZumkellerNumbers.jl ****************
"""
Is ``n`` a Zumkeller number? A Zumkeller number ``n`` is an integer whose divisors can be partitioned into two disjoint sets whose sums are both ``σ(n)/2``.
$(SIGNATURES)
"""
function isZumkeller(n::Int)
    n == 0 && return false
    s = σ(n)
    ((s % 2 ≠ 0) || (s < 2n)) && return false
    S = s >> 1 - n
    D = [d for d in Divisors(n) if d ≤ S]
    D == [] && return true
    for c in Combinations(D)
        S == sum(c) && return true
    end
    return false
end
"""
Is ``n`` a Zumkeller number?
$(SIGNATURES)
"""
is083207(n) = isZumkeller(n)
"""
Iterate over the first ``n`` Zumkeller numbers.
$(SIGNATURES)
"""
I083207(n) = Iterators.take(Iterators.filter(isZumkeller, Iterators.countfrom(1)), n)
"""
Iterate over the Zumkeller numbers ``z`` which are below ``n, (1 ≤ z ≤ n)``.
$(SIGNATURES)
"""
F083207(n) = Iterators.filter(isZumkeller, 1:n)
"""
List the first ``n`` Zumkeller numbers.
$(SIGNATURES)
"""
L083207(n) = collect(I083207(n))
"""
Return the ``n``-th Zumkeller number.
$(SIGNATURES)
"""
V083207(n) = nth(I083207(n), n)
end
